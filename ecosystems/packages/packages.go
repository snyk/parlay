// Package packages provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package packages

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Advisory defines model for Advisory.
type Advisory struct {
	Classification *string                  `json:"classification"`
	CreatedAt      string                   `json:"created_at"`
	CvssScore      *float32                 `json:"cvss_score"`
	CvssVector     *string                  `json:"cvss_vector"`
	Description    *string                  `json:"description"`
	Identifiers    []string                 `json:"identifiers"`
	Origin         *string                  `json:"origin"`
	Packages       []map[string]interface{} `json:"packages"`
	PublishedAt    *string                  `json:"published_at"`
	References     []string                 `json:"references"`
	Severity       *string                  `json:"severity"`
	SourceKind     *string                  `json:"source_kind"`
	Title          *string                  `json:"title"`
	UpdatedAt      string                   `json:"updated_at"`
	Url            *string                  `json:"url"`
	Uuid           string                   `json:"uuid"`
	WithdrawnAt    *string                  `json:"withdrawn_at"`
}

// Dependency defines model for Dependency.
type Dependency struct {
	Ecosystem    string  `json:"ecosystem"`
	Id           int     `json:"id"`
	Kind         *string `json:"kind"`
	Optional     *bool   `json:"optional"`
	PackageName  string  `json:"package_name"`
	Requirements *string `json:"requirements"`
}

// Keyword defines model for Keyword.
type Keyword struct {
	Name          string `json:"name"`
	PackagesCount int    `json:"packages_count"`
	PackagesUrl   string `json:"packages_url"`
}

// KeywordWithPackages defines model for KeywordWithPackages.
type KeywordWithPackages struct {
	Name            string    `json:"name"`
	Packages        []Package `json:"packages"`
	PackagesCount   int       `json:"packages_count"`
	PackagesUrl     string    `json:"packages_url"`
	RelatedKeywords []Keyword `json:"related_keywords"`
}

// Maintainer defines model for Maintainer.
type Maintainer struct {
	CreatedAt      time.Time `json:"created_at"`
	Email          *string   `json:"email"`
	HtmlUrl        *string   `json:"html_url"`
	Login          *string   `json:"login"`
	Name           *string   `json:"name"`
	PackagesCount  int       `json:"packages_count"`
	PackagesUrl    string    `json:"packages_url"`
	Role           *string   `json:"role"`
	TotalDownloads int       `json:"total_downloads"`
	UpdatedAt      time.Time `json:"updated_at"`
	Url            *string   `json:"url"`
	Uuid           string    `json:"uuid"`
}

// Namespace defines model for Namespace.
type Namespace struct {
	Name          string `json:"name"`
	PackagesCount int    `json:"packages_count"`
	PackagesUrl   string `json:"packages_url"`
}

// Package defines model for Package.
type Package struct {
	Advisories               []Advisory              `json:"advisories"`
	CreatedAt                time.Time               `json:"created_at"`
	Critical                 bool                    `json:"critical"`
	DependentPackagesCount   int                     `json:"dependent_packages_count"`
	DependentPackagesUrl     string                  `json:"dependent_packages_url"`
	DependentReposCount      int                     `json:"dependent_repos_count"`
	DependentRepositoriesUrl string                  `json:"dependent_repositories_url"`
	Description              *string                 `json:"description"`
	DockerDependentsCount    int                     `json:"docker_dependents_count"`
	DockerDownloadsCount     int                     `json:"docker_downloads_count"`
	DockerUsageUrl           string                  `json:"docker_usage_url"`
	DocumentationUrl         *string                 `json:"documentation_url"`
	Downloads                int                     `json:"downloads"`
	DownloadsPeriod          *string                 `json:"downloads_period"`
	Ecosystem                string                  `json:"ecosystem"`
	FirstReleasePublishedAt  *time.Time              `json:"first_release_published_at"`
	FundingLinks             []string                `json:"funding_links"`
	Homepage                 *string                 `json:"homepage"`
	Id                       int                     `json:"id"`
	InstallCommand           *string                 `json:"install_command"`
	KeywordsArray            []string                `json:"keywords_array"`
	LastSyncedAt             *time.Time              `json:"last_synced_at"`
	LatestReleaseNumber      *string                 `json:"latest_release_number"`
	LatestReleasePublishedAt *time.Time              `json:"latest_release_published_at"`
	Licenses                 *string                 `json:"licenses"`
	Maintainers              []Maintainer            `json:"maintainers"`
	Metadata                 *map[string]interface{} `json:"metadata"`
	Name                     string                  `json:"name"`
	Namespace                *string                 `json:"namespace"`
	NormalizedLicenses       []string                `json:"normalized_licenses"`
	Purl                     string                  `json:"purl"`
	Rankings                 map[string]interface{}  `json:"rankings"`
	RegistryUrl              *string                 `json:"registry_url"`
	RelatedPackagesUrl       string                  `json:"related_packages_url"`
	RepoMetadata             *map[string]interface{} `json:"repo_metadata"`
	RepoMetadataUpdatedAt    *time.Time              `json:"repo_metadata_updated_at"`
	RepositoryUrl            *string                 `json:"repository_url"`
	Status                   *string                 `json:"status"`
	UpdatedAt                time.Time               `json:"updated_at"`
	UsageUrl                 string                  `json:"usage_url"`
	VersionNumbersUrl        *string                 `json:"version_numbers_url,omitempty"`
	VersionsCount            int                     `json:"versions_count"`
	VersionsUrl              string                  `json:"versions_url"`
}

// PackageWithRegistry defines model for PackageWithRegistry.
type PackageWithRegistry struct {
	Advisories               []Advisory              `json:"advisories"`
	CreatedAt                time.Time               `json:"created_at"`
	Critical                 bool                    `json:"critical"`
	DependentPackagesCount   int                     `json:"dependent_packages_count"`
	DependentPackagesUrl     string                  `json:"dependent_packages_url"`
	DependentReposCount      int                     `json:"dependent_repos_count"`
	DependentRepositoriesUrl string                  `json:"dependent_repositories_url"`
	Description              *string                 `json:"description"`
	DockerDependentsCount    int                     `json:"docker_dependents_count"`
	DockerDownloadsCount     int                     `json:"docker_downloads_count"`
	DockerUsageUrl           string                  `json:"docker_usage_url"`
	DocumentationUrl         *string                 `json:"documentation_url"`
	Downloads                int                     `json:"downloads"`
	DownloadsPeriod          *string                 `json:"downloads_period"`
	Ecosystem                string                  `json:"ecosystem"`
	FirstReleasePublishedAt  *time.Time              `json:"first_release_published_at"`
	FundingLinks             []string                `json:"funding_links"`
	Homepage                 *string                 `json:"homepage"`
	Id                       int                     `json:"id"`
	InstallCommand           *string                 `json:"install_command"`
	KeywordsArray            []string                `json:"keywords_array"`
	LastSyncedAt             *time.Time              `json:"last_synced_at"`
	LatestReleaseNumber      *string                 `json:"latest_release_number"`
	LatestReleasePublishedAt *time.Time              `json:"latest_release_published_at"`
	Licenses                 *string                 `json:"licenses"`
	Maintainers              []Maintainer            `json:"maintainers"`
	Metadata                 *map[string]interface{} `json:"metadata"`
	Name                     string                  `json:"name"`
	Namespace                *string                 `json:"namespace"`
	NormalizedLicenses       []string                `json:"normalized_licenses"`
	Purl                     string                  `json:"purl"`
	Rankings                 map[string]interface{}  `json:"rankings"`
	Registry                 Registry                `json:"registry"`
	RegistryUrl              *string                 `json:"registry_url"`
	RelatedPackagesUrl       string                  `json:"related_packages_url"`
	RepoMetadata             *map[string]interface{} `json:"repo_metadata"`
	RepoMetadataUpdatedAt    *time.Time              `json:"repo_metadata_updated_at"`
	RepositoryUrl            *string                 `json:"repository_url"`
	Status                   *string                 `json:"status"`
	UpdatedAt                time.Time               `json:"updated_at"`
	UsageUrl                 string                  `json:"usage_url"`
	VersionNumbersUrl        *string                 `json:"version_numbers_url,omitempty"`
	VersionsCount            int                     `json:"versions_count"`
	VersionsUrl              string                  `json:"versions_url"`
}

// Registry defines model for Registry.
type Registry struct {
	CreatedAt        time.Time               `json:"created_at"`
	Default          bool                    `json:"default"`
	Downloads        int64                   `json:"downloads"`
	Ecosystem        string                  `json:"ecosystem"`
	Github           *string                 `json:"github"`
	IconUrl          string                  `json:"icon_url"`
	KeywordsCount    int64                   `json:"keywords_count"`
	MaintainersCount int64                   `json:"maintainers_count"`
	MaintainersUrl   string                  `json:"maintainers_url"`
	Metadata         *map[string]interface{} `json:"metadata"`
	Name             string                  `json:"name"`
	NamespacesCount  int64                   `json:"namespaces_count"`
	PackagesCount    int64                   `json:"packages_count"`
	PackagesUrl      string                  `json:"packages_url"`
	PurlType         string                  `json:"purl_type"`
	UpdatedAt        time.Time               `json:"updated_at"`
	Url              string                  `json:"url"`
	VersionsCount    *int64                  `json:"versions_count,omitempty"`
}

// Version defines model for Version.
type Version struct {
	CreatedAt        time.Time               `json:"created_at"`
	DocumentationUrl *string                 `json:"documentation_url"`
	DownloadUrl      *string                 `json:"download_url"`
	Id               int                     `json:"id"`
	InstallCommand   *string                 `json:"install_command"`
	Integrity        *string                 `json:"integrity"`
	Licenses         *string                 `json:"licenses"`
	Metadata         *map[string]interface{} `json:"metadata"`
	Number           string                  `json:"number"`
	PublishedAt      *string                 `json:"published_at"`
	Purl             string                  `json:"purl"`
	RegistryUrl      *string                 `json:"registry_url"`
	RelatedTag       map[string]interface{}  `json:"related_tag"`
	Status           *string                 `json:"status"`
	UpdatedAt        time.Time               `json:"updated_at"`
	VersionUrl       string                  `json:"version_url"`
}

// VersionWithDependencies defines model for VersionWithDependencies.
type VersionWithDependencies struct {
	CreatedAt        time.Time               `json:"created_at"`
	Dependencies     []Dependency            `json:"dependencies"`
	DocumentationUrl *string                 `json:"documentation_url"`
	DownloadUrl      *string                 `json:"download_url"`
	Id               *int                    `json:"id,omitempty"`
	InstallCommand   *string                 `json:"install_command"`
	Integrity        *string                 `json:"integrity"`
	Latest           bool                    `json:"latest"`
	Licenses         *string                 `json:"licenses"`
	Metadata         *map[string]interface{} `json:"metadata"`
	Number           string                  `json:"number"`
	PublishedAt      *string                 `json:"published_at"`
	Purl             string                  `json:"purl"`
	RegistryUrl      *string                 `json:"registry_url"`
	RelatedTag       map[string]interface{}  `json:"related_tag"`
	Status           *string                 `json:"status"`
	UpdatedAt        time.Time               `json:"updated_at"`
	VersionUrl       string                  `json:"version_url"`
}

// VersionWithPackage defines model for VersionWithPackage.
type VersionWithPackage struct {
	CreatedAt        time.Time               `json:"created_at"`
	DocumentationUrl *string                 `json:"documentation_url"`
	DownloadUrl      *string                 `json:"download_url"`
	Id               int                     `json:"id"`
	InstallCommand   *string                 `json:"install_command"`
	Integrity        *string                 `json:"integrity"`
	Latest           bool                    `json:"latest"`
	Licenses         *string                 `json:"licenses"`
	Metadata         *map[string]interface{} `json:"metadata"`
	Number           string                  `json:"number"`
	PackageUrl       string                  `json:"package_url"`
	PublishedAt      *string                 `json:"published_at"`
	Purl             string                  `json:"purl"`
	RegistryUrl      *string                 `json:"registry_url"`
	Status           *string                 `json:"status"`
	UpdatedAt        time.Time               `json:"updated_at"`
	VersionUrl       string                  `json:"version_url"`
}

// GetDependenciesParams defines parameters for GetDependencies.
type GetDependenciesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// Ecosystem ecosystem name
	Ecosystem *string `form:"ecosystem,omitempty" json:"ecosystem,omitempty"`

	// PackageName package name
	PackageName *string `form:"package_name,omitempty" json:"package_name,omitempty"`

	// PackageId package id
	PackageId *string `form:"package_id,omitempty" json:"package_id,omitempty"`

	// Requirements requirements
	Requirements *string `form:"requirements,omitempty" json:"requirements,omitempty"`

	// Kind kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`

	// Optional optional
	Optional *bool `form:"optional,omitempty" json:"optional,omitempty"`

	// After filter by id after given id
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetKeywordsParams defines parameters for GetKeywords.
type GetKeywordsParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetKeywordParams defines parameters for GetKeyword.
type GetKeywordParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// LookupPackageParams defines parameters for LookupPackage.
type LookupPackageParams struct {
	// RepositoryUrl repository URL
	RepositoryUrl *string `form:"repository_url,omitempty" json:"repository_url,omitempty"`

	// Purl package URL
	Purl *string `form:"purl,omitempty" json:"purl,omitempty"`

	// Ecosystem ecosystem name
	Ecosystem *string `form:"ecosystem,omitempty" json:"ecosystem,omitempty"`

	// Name package name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort field to sort results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to sort results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistriesParams defines parameters for GetRegistries.
type GetRegistriesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetRegistryParams defines parameters for GetRegistry.
type GetRegistryParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// LookupRegistryPackageParams defines parameters for LookupRegistryPackage.
type LookupRegistryPackageParams struct {
	// RepositoryUrl repository URL
	RepositoryUrl *string `form:"repository_url,omitempty" json:"repository_url,omitempty"`

	// Purl package URL
	Purl *string `form:"purl,omitempty" json:"purl,omitempty"`

	// Ecosystem ecosystem name
	Ecosystem *string `form:"ecosystem,omitempty" json:"ecosystem,omitempty"`

	// Name package name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Sort field to sort results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to sort results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistryMaintainersParams defines parameters for GetRegistryMaintainers.
type GetRegistryMaintainersParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistryMaintainerPackagesParams defines parameters for GetRegistryMaintainerPackages.
type GetRegistryMaintainerPackagesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetRegistryNamespacesParams defines parameters for GetRegistryNamespaces.
type GetRegistryNamespacesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetRegistryNamespacePackagesParams defines parameters for GetRegistryNamespacePackages.
type GetRegistryNamespacePackagesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetRegistryPackageNamesParams defines parameters for GetRegistryPackageNames.
type GetRegistryPackageNamesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// CreatedBefore filter by created_at before given time
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// UpdatedBefore filter by updated_at before given time
	UpdatedBefore *time.Time `form:"updated_before,omitempty" json:"updated_before,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistryPackagesParams defines parameters for GetRegistryPackages.
type GetRegistryPackagesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// CreatedBefore filter by created_at before given time
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// UpdatedBefore filter by updated_at before given time
	UpdatedBefore *time.Time `form:"updated_before,omitempty" json:"updated_before,omitempty"`

	// Critical filter by critical packages
	Critical *bool `form:"critical,omitempty" json:"critical,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistryPackageDependentPackageKindsParams defines parameters for GetRegistryPackageDependentPackageKinds.
type GetRegistryPackageDependentPackageKindsParams struct {
	// Latest filter by latest version
	Latest *bool `form:"latest,omitempty" json:"latest,omitempty"`
}

// GetRegistryPackageDependentPackagesParams defines parameters for GetRegistryPackageDependentPackages.
type GetRegistryPackageDependentPackagesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`

	// Latest filter by latest version
	Latest *bool `form:"latest,omitempty" json:"latest,omitempty"`

	// Kind filter by dependency kind
	Kind *string `form:"kind,omitempty" json:"kind,omitempty"`
}

// GetRegistryPackageRelatedPackagesParams defines parameters for GetRegistryPackageRelatedPackages.
type GetRegistryPackageRelatedPackagesParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistryPackageVersionsParams defines parameters for GetRegistryPackageVersions.
type GetRegistryPackageVersionsParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// PublishedAfter filter by published_at after given time
	PublishedAfter *time.Time `form:"published_after,omitempty" json:"published_after,omitempty"`

	// PublishedBefore filter by published_at before given time
	PublishedBefore *time.Time `form:"published_before,omitempty" json:"published_before,omitempty"`

	// CreatedBefore filter by created_at before given time
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// UpdatedBefore filter by updated_at before given time
	UpdatedBefore *time.Time `form:"updated_before,omitempty" json:"updated_before,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// GetRegistryRecentVersionsParams defines parameters for GetRegistryRecentVersions.
type GetRegistryRecentVersionsParams struct {
	// Page pagination page number
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of records to return
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// CreatedAfter filter by created_at after given time
	CreatedAfter *time.Time `form:"created_after,omitempty" json:"created_after,omitempty"`

	// UpdatedAfter filter by updated_at after given time
	UpdatedAfter *time.Time `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// PublishedAfter filter by published_at after given time
	PublishedAfter *time.Time `form:"published_after,omitempty" json:"published_after,omitempty"`

	// PublishedBefore filter by published_at before given time
	PublishedBefore *time.Time `form:"published_before,omitempty" json:"published_before,omitempty"`

	// CreatedBefore filter by created_at before given time
	CreatedBefore *time.Time `form:"created_before,omitempty" json:"created_before,omitempty"`

	// UpdatedBefore filter by updated_at before given time
	UpdatedBefore *time.Time `form:"updated_before,omitempty" json:"updated_before,omitempty"`

	// Sort field to order results by
	Sort *string `form:"sort,omitempty" json:"sort,omitempty"`

	// Order direction to order results by
	Order *string `form:"order,omitempty" json:"order,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetDependencies request
	GetDependencies(ctx context.Context, params *GetDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeywords request
	GetKeywords(ctx context.Context, params *GetKeywordsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeyword request
	GetKeyword(ctx context.Context, keywordName string, params *GetKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupPackage request
	LookupPackage(ctx context.Context, params *LookupPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistries request
	GetRegistries(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistry request
	GetRegistry(ctx context.Context, registryName string, params *GetRegistryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LookupRegistryPackage request
	LookupRegistryPackage(ctx context.Context, registryName string, params *LookupRegistryPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryMaintainers request
	GetRegistryMaintainers(ctx context.Context, registryName string, params *GetRegistryMaintainersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryMaintainer request
	GetRegistryMaintainer(ctx context.Context, registryName string, maintainerLoginOrUUID string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryMaintainerPackages request
	GetRegistryMaintainerPackages(ctx context.Context, registryName string, maintainerLoginOrUUID string, params *GetRegistryMaintainerPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryNamespaces request
	GetRegistryNamespaces(ctx context.Context, registryName string, params *GetRegistryNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryNamespace request
	GetRegistryNamespace(ctx context.Context, registryName string, namespaceName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryNamespacePackages request
	GetRegistryNamespacePackages(ctx context.Context, registryName string, namespaceName string, params *GetRegistryNamespacePackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageNames request
	GetRegistryPackageNames(ctx context.Context, registryName string, params *GetRegistryPackageNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackages request
	GetRegistryPackages(ctx context.Context, registryName string, params *GetRegistryPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackage request
	GetRegistryPackage(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageDependentPackageKinds request
	GetRegistryPackageDependentPackageKinds(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackageKindsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageDependentPackages request
	GetRegistryPackageDependentPackages(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageRelatedPackages request
	GetRegistryPackageRelatedPackages(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageRelatedPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageVersionNumbers request
	GetRegistryPackageVersionNumbers(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageVersions request
	GetRegistryPackageVersions(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryPackageVersion request
	GetRegistryPackageVersion(ctx context.Context, registryName string, packageName string, versionNumber string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRegistryRecentVersions request
	GetRegistryRecentVersions(ctx context.Context, registryName string, params *GetRegistryRecentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetDependencies(ctx context.Context, params *GetDependenciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDependenciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeywords(ctx context.Context, params *GetKeywordsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeywordsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeyword(ctx context.Context, keywordName string, params *GetKeywordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeywordRequest(c.Server, keywordName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupPackage(ctx context.Context, params *LookupPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupPackageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistries(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistry(ctx context.Context, registryName string, params *GetRegistryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LookupRegistryPackage(ctx context.Context, registryName string, params *LookupRegistryPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLookupRegistryPackageRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryMaintainers(ctx context.Context, registryName string, params *GetRegistryMaintainersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryMaintainersRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryMaintainer(ctx context.Context, registryName string, maintainerLoginOrUUID string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryMaintainerRequest(c.Server, registryName, maintainerLoginOrUUID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryMaintainerPackages(ctx context.Context, registryName string, maintainerLoginOrUUID string, params *GetRegistryMaintainerPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryMaintainerPackagesRequest(c.Server, registryName, maintainerLoginOrUUID, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryNamespaces(ctx context.Context, registryName string, params *GetRegistryNamespacesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryNamespacesRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryNamespace(ctx context.Context, registryName string, namespaceName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryNamespaceRequest(c.Server, registryName, namespaceName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryNamespacePackages(ctx context.Context, registryName string, namespaceName string, params *GetRegistryNamespacePackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryNamespacePackagesRequest(c.Server, registryName, namespaceName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageNames(ctx context.Context, registryName string, params *GetRegistryPackageNamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageNamesRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackages(ctx context.Context, registryName string, params *GetRegistryPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackagesRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackage(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageRequest(c.Server, registryName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageDependentPackageKinds(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackageKindsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageDependentPackageKindsRequest(c.Server, registryName, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageDependentPackages(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageDependentPackagesRequest(c.Server, registryName, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageRelatedPackages(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageRelatedPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageRelatedPackagesRequest(c.Server, registryName, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageVersionNumbers(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageVersionNumbersRequest(c.Server, registryName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageVersions(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageVersionsRequest(c.Server, registryName, packageName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryPackageVersion(ctx context.Context, registryName string, packageName string, versionNumber string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryPackageVersionRequest(c.Server, registryName, packageName, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRegistryRecentVersions(ctx context.Context, registryName string, params *GetRegistryRecentVersionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRegistryRecentVersionsRequest(c.Server, registryName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetDependenciesRequest generates requests for GetDependencies
func NewGetDependenciesRequest(server string, params *GetDependenciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dependencies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ecosystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecosystem", runtime.ParamLocationQuery, *params.Ecosystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PackageName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package_name", runtime.ParamLocationQuery, *params.PackageName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PackageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "package_id", runtime.ParamLocationQuery, *params.PackageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Requirements != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requirements", runtime.ParamLocationQuery, *params.Requirements); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Optional != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "optional", runtime.ParamLocationQuery, *params.Optional); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeywordsRequest generates requests for GetKeywords
func NewGetKeywordsRequest(server string, params *GetKeywordsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keywords")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeywordRequest generates requests for GetKeyword
func NewGetKeywordRequest(server string, keywordName string, params *GetKeywordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "keywordName", runtime.ParamLocationPath, keywordName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/keywords/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLookupPackageRequest generates requests for LookupPackage
func NewLookupPackageRequest(server string, params *LookupPackageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/lookup")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RepositoryUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository_url", runtime.ParamLocationQuery, *params.RepositoryUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Purl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purl", runtime.ParamLocationQuery, *params.Purl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ecosystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecosystem", runtime.ParamLocationQuery, *params.Ecosystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistriesRequest generates requests for GetRegistries
func NewGetRegistriesRequest(server string, params *GetRegistriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryRequest generates requests for GetRegistry
func NewGetRegistryRequest(server string, registryName string, params *GetRegistryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLookupRegistryPackageRequest generates requests for LookupRegistryPackage
func NewLookupRegistryPackageRequest(server string, registryName string, params *LookupRegistryPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/lookup", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.RepositoryUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repository_url", runtime.ParamLocationQuery, *params.RepositoryUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Purl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "purl", runtime.ParamLocationQuery, *params.Purl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ecosystem != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ecosystem", runtime.ParamLocationQuery, *params.Ecosystem); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryMaintainersRequest generates requests for GetRegistryMaintainers
func NewGetRegistryMaintainersRequest(server string, registryName string, params *GetRegistryMaintainersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/maintainers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryMaintainerRequest generates requests for GetRegistryMaintainer
func NewGetRegistryMaintainerRequest(server string, registryName string, maintainerLoginOrUUID string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "MaintainerLoginOrUUID", runtime.ParamLocationPath, maintainerLoginOrUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/maintainers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryMaintainerPackagesRequest generates requests for GetRegistryMaintainerPackages
func NewGetRegistryMaintainerPackagesRequest(server string, registryName string, maintainerLoginOrUUID string, params *GetRegistryMaintainerPackagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "MaintainerLoginOrUUID", runtime.ParamLocationPath, maintainerLoginOrUUID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/maintainers/%s/packages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryNamespacesRequest generates requests for GetRegistryNamespaces
func NewGetRegistryNamespacesRequest(server string, registryName string, params *GetRegistryNamespacesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/namespaces", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryNamespaceRequest generates requests for GetRegistryNamespace
func NewGetRegistryNamespaceRequest(server string, registryName string, namespaceName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespaceName", runtime.ParamLocationPath, namespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/namespaces/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryNamespacePackagesRequest generates requests for GetRegistryNamespacePackages
func NewGetRegistryNamespacePackagesRequest(server string, registryName string, namespaceName string, params *GetRegistryNamespacePackagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "namespaceName", runtime.ParamLocationPath, namespaceName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/namespaces/%s/packages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageNamesRequest generates requests for GetRegistryPackageNames
func NewGetRegistryPackageNamesRequest(server string, registryName string, params *GetRegistryPackageNamesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/package_names", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_before", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackagesRequest generates requests for GetRegistryPackages
func NewGetRegistryPackagesRequest(server string, registryName string, params *GetRegistryPackagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_before", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Critical != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "critical", runtime.ParamLocationQuery, *params.Critical); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageRequest generates requests for GetRegistryPackage
func NewGetRegistryPackageRequest(server string, registryName string, packageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageDependentPackageKindsRequest generates requests for GetRegistryPackageDependentPackageKinds
func NewGetRegistryPackageDependentPackageKindsRequest(server string, registryName string, packageName string, params *GetRegistryPackageDependentPackageKindsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s/dependent_package_kinds", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Latest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "latest", runtime.ParamLocationQuery, *params.Latest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageDependentPackagesRequest generates requests for GetRegistryPackageDependentPackages
func NewGetRegistryPackageDependentPackagesRequest(server string, registryName string, packageName string, params *GetRegistryPackageDependentPackagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s/dependent_packages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Latest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "latest", runtime.ParamLocationQuery, *params.Latest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageRelatedPackagesRequest generates requests for GetRegistryPackageRelatedPackages
func NewGetRegistryPackageRelatedPackagesRequest(server string, registryName string, packageName string, params *GetRegistryPackageRelatedPackagesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s/related_packages", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageVersionNumbersRequest generates requests for GetRegistryPackageVersionNumbers
func NewGetRegistryPackageVersionNumbersRequest(server string, registryName string, packageName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s/version_numbers", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageVersionsRequest generates requests for GetRegistryPackageVersions
func NewGetRegistryPackageVersionsRequest(server string, registryName string, packageName string, params *GetRegistryPackageVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_after", runtime.ParamLocationQuery, *params.PublishedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_before", runtime.ParamLocationQuery, *params.PublishedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_before", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryPackageVersionRequest generates requests for GetRegistryPackageVersion
func NewGetRegistryPackageVersionRequest(server string, registryName string, packageName string, versionNumber string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "versionNumber", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/packages/%s/versions/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRegistryRecentVersionsRequest generates requests for GetRegistryRecentVersions
func NewGetRegistryRecentVersionsRequest(server string, registryName string, params *GetRegistryRecentVersionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "registryName", runtime.ParamLocationPath, registryName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/registries/%s/versions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_after", runtime.ParamLocationQuery, *params.PublishedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "published_before", runtime.ParamLocationQuery, *params.PublishedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_before", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetDependenciesWithResponse request
	GetDependenciesWithResponse(ctx context.Context, params *GetDependenciesParams, reqEditors ...RequestEditorFn) (*GetDependenciesResponse, error)

	// GetKeywordsWithResponse request
	GetKeywordsWithResponse(ctx context.Context, params *GetKeywordsParams, reqEditors ...RequestEditorFn) (*GetKeywordsResponse, error)

	// GetKeywordWithResponse request
	GetKeywordWithResponse(ctx context.Context, keywordName string, params *GetKeywordParams, reqEditors ...RequestEditorFn) (*GetKeywordResponse, error)

	// LookupPackageWithResponse request
	LookupPackageWithResponse(ctx context.Context, params *LookupPackageParams, reqEditors ...RequestEditorFn) (*LookupPackageResponse, error)

	// GetRegistriesWithResponse request
	GetRegistriesWithResponse(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*GetRegistriesResponse, error)

	// GetRegistryWithResponse request
	GetRegistryWithResponse(ctx context.Context, registryName string, params *GetRegistryParams, reqEditors ...RequestEditorFn) (*GetRegistryResponse, error)

	// LookupRegistryPackageWithResponse request
	LookupRegistryPackageWithResponse(ctx context.Context, registryName string, params *LookupRegistryPackageParams, reqEditors ...RequestEditorFn) (*LookupRegistryPackageResponse, error)

	// GetRegistryMaintainersWithResponse request
	GetRegistryMaintainersWithResponse(ctx context.Context, registryName string, params *GetRegistryMaintainersParams, reqEditors ...RequestEditorFn) (*GetRegistryMaintainersResponse, error)

	// GetRegistryMaintainerWithResponse request
	GetRegistryMaintainerWithResponse(ctx context.Context, registryName string, maintainerLoginOrUUID string, reqEditors ...RequestEditorFn) (*GetRegistryMaintainerResponse, error)

	// GetRegistryMaintainerPackagesWithResponse request
	GetRegistryMaintainerPackagesWithResponse(ctx context.Context, registryName string, maintainerLoginOrUUID string, params *GetRegistryMaintainerPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryMaintainerPackagesResponse, error)

	// GetRegistryNamespacesWithResponse request
	GetRegistryNamespacesWithResponse(ctx context.Context, registryName string, params *GetRegistryNamespacesParams, reqEditors ...RequestEditorFn) (*GetRegistryNamespacesResponse, error)

	// GetRegistryNamespaceWithResponse request
	GetRegistryNamespaceWithResponse(ctx context.Context, registryName string, namespaceName string, reqEditors ...RequestEditorFn) (*GetRegistryNamespaceResponse, error)

	// GetRegistryNamespacePackagesWithResponse request
	GetRegistryNamespacePackagesWithResponse(ctx context.Context, registryName string, namespaceName string, params *GetRegistryNamespacePackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryNamespacePackagesResponse, error)

	// GetRegistryPackageNamesWithResponse request
	GetRegistryPackageNamesWithResponse(ctx context.Context, registryName string, params *GetRegistryPackageNamesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageNamesResponse, error)

	// GetRegistryPackagesWithResponse request
	GetRegistryPackagesWithResponse(ctx context.Context, registryName string, params *GetRegistryPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackagesResponse, error)

	// GetRegistryPackageWithResponse request
	GetRegistryPackageWithResponse(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*GetRegistryPackageResponse, error)

	// GetRegistryPackageDependentPackageKindsWithResponse request
	GetRegistryPackageDependentPackageKindsWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackageKindsParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageDependentPackageKindsResponse, error)

	// GetRegistryPackageDependentPackagesWithResponse request
	GetRegistryPackageDependentPackagesWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageDependentPackagesResponse, error)

	// GetRegistryPackageRelatedPackagesWithResponse request
	GetRegistryPackageRelatedPackagesWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageRelatedPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageRelatedPackagesResponse, error)

	// GetRegistryPackageVersionNumbersWithResponse request
	GetRegistryPackageVersionNumbersWithResponse(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*GetRegistryPackageVersionNumbersResponse, error)

	// GetRegistryPackageVersionsWithResponse request
	GetRegistryPackageVersionsWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageVersionsParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageVersionsResponse, error)

	// GetRegistryPackageVersionWithResponse request
	GetRegistryPackageVersionWithResponse(ctx context.Context, registryName string, packageName string, versionNumber string, reqEditors ...RequestEditorFn) (*GetRegistryPackageVersionResponse, error)

	// GetRegistryRecentVersionsWithResponse request
	GetRegistryRecentVersionsWithResponse(ctx context.Context, registryName string, params *GetRegistryRecentVersionsParams, reqEditors ...RequestEditorFn) (*GetRegistryRecentVersionsResponse, error)
}

type GetDependenciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Dependency
}

// Status returns HTTPResponse.Status
func (r GetDependenciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDependenciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeywordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Keyword
}

// Status returns HTTPResponse.Status
func (r GetKeywordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeywordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeywordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeywordWithPackages
}

// Status returns HTTPResponse.Status
func (r GetKeywordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeywordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageWithRegistry
}

// Status returns HTTPResponse.Status
func (r LookupPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Registry
}

// Status returns HTTPResponse.Status
func (r GetRegistriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Registry
}

// Status returns HTTPResponse.Status
func (r GetRegistryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LookupRegistryPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageWithRegistry
}

// Status returns HTTPResponse.Status
func (r LookupRegistryPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LookupRegistryPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryMaintainersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Maintainer
}

// Status returns HTTPResponse.Status
func (r GetRegistryMaintainersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryMaintainersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryMaintainerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Maintainer
}

// Status returns HTTPResponse.Status
func (r GetRegistryMaintainerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryMaintainerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryMaintainerPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
}

// Status returns HTTPResponse.Status
func (r GetRegistryMaintainerPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryMaintainerPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryNamespacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Namespace
}

// Status returns HTTPResponse.Status
func (r GetRegistryNamespacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryNamespacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryNamespaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Namespace
}

// Status returns HTTPResponse.Status
func (r GetRegistryNamespaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryNamespaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryNamespacePackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
}

// Status returns HTTPResponse.Status
func (r GetRegistryNamespacePackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryNamespacePackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageNamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageNamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageNamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Package
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageDependentPackageKindsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageDependentPackageKindsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageDependentPackageKindsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageDependentPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageDependentPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageDependentPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageRelatedPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Package
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageRelatedPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageRelatedPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageVersionNumbersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageVersionNumbersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageVersionNumbersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Version
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryPackageVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *VersionWithDependencies
}

// Status returns HTTPResponse.Status
func (r GetRegistryPackageVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryPackageVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRegistryRecentVersionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]VersionWithPackage
}

// Status returns HTTPResponse.Status
func (r GetRegistryRecentVersionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRegistryRecentVersionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetDependenciesWithResponse request returning *GetDependenciesResponse
func (c *ClientWithResponses) GetDependenciesWithResponse(ctx context.Context, params *GetDependenciesParams, reqEditors ...RequestEditorFn) (*GetDependenciesResponse, error) {
	rsp, err := c.GetDependencies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDependenciesResponse(rsp)
}

// GetKeywordsWithResponse request returning *GetKeywordsResponse
func (c *ClientWithResponses) GetKeywordsWithResponse(ctx context.Context, params *GetKeywordsParams, reqEditors ...RequestEditorFn) (*GetKeywordsResponse, error) {
	rsp, err := c.GetKeywords(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeywordsResponse(rsp)
}

// GetKeywordWithResponse request returning *GetKeywordResponse
func (c *ClientWithResponses) GetKeywordWithResponse(ctx context.Context, keywordName string, params *GetKeywordParams, reqEditors ...RequestEditorFn) (*GetKeywordResponse, error) {
	rsp, err := c.GetKeyword(ctx, keywordName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeywordResponse(rsp)
}

// LookupPackageWithResponse request returning *LookupPackageResponse
func (c *ClientWithResponses) LookupPackageWithResponse(ctx context.Context, params *LookupPackageParams, reqEditors ...RequestEditorFn) (*LookupPackageResponse, error) {
	rsp, err := c.LookupPackage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupPackageResponse(rsp)
}

// GetRegistriesWithResponse request returning *GetRegistriesResponse
func (c *ClientWithResponses) GetRegistriesWithResponse(ctx context.Context, params *GetRegistriesParams, reqEditors ...RequestEditorFn) (*GetRegistriesResponse, error) {
	rsp, err := c.GetRegistries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistriesResponse(rsp)
}

// GetRegistryWithResponse request returning *GetRegistryResponse
func (c *ClientWithResponses) GetRegistryWithResponse(ctx context.Context, registryName string, params *GetRegistryParams, reqEditors ...RequestEditorFn) (*GetRegistryResponse, error) {
	rsp, err := c.GetRegistry(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryResponse(rsp)
}

// LookupRegistryPackageWithResponse request returning *LookupRegistryPackageResponse
func (c *ClientWithResponses) LookupRegistryPackageWithResponse(ctx context.Context, registryName string, params *LookupRegistryPackageParams, reqEditors ...RequestEditorFn) (*LookupRegistryPackageResponse, error) {
	rsp, err := c.LookupRegistryPackage(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLookupRegistryPackageResponse(rsp)
}

// GetRegistryMaintainersWithResponse request returning *GetRegistryMaintainersResponse
func (c *ClientWithResponses) GetRegistryMaintainersWithResponse(ctx context.Context, registryName string, params *GetRegistryMaintainersParams, reqEditors ...RequestEditorFn) (*GetRegistryMaintainersResponse, error) {
	rsp, err := c.GetRegistryMaintainers(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryMaintainersResponse(rsp)
}

// GetRegistryMaintainerWithResponse request returning *GetRegistryMaintainerResponse
func (c *ClientWithResponses) GetRegistryMaintainerWithResponse(ctx context.Context, registryName string, maintainerLoginOrUUID string, reqEditors ...RequestEditorFn) (*GetRegistryMaintainerResponse, error) {
	rsp, err := c.GetRegistryMaintainer(ctx, registryName, maintainerLoginOrUUID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryMaintainerResponse(rsp)
}

// GetRegistryMaintainerPackagesWithResponse request returning *GetRegistryMaintainerPackagesResponse
func (c *ClientWithResponses) GetRegistryMaintainerPackagesWithResponse(ctx context.Context, registryName string, maintainerLoginOrUUID string, params *GetRegistryMaintainerPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryMaintainerPackagesResponse, error) {
	rsp, err := c.GetRegistryMaintainerPackages(ctx, registryName, maintainerLoginOrUUID, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryMaintainerPackagesResponse(rsp)
}

// GetRegistryNamespacesWithResponse request returning *GetRegistryNamespacesResponse
func (c *ClientWithResponses) GetRegistryNamespacesWithResponse(ctx context.Context, registryName string, params *GetRegistryNamespacesParams, reqEditors ...RequestEditorFn) (*GetRegistryNamespacesResponse, error) {
	rsp, err := c.GetRegistryNamespaces(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryNamespacesResponse(rsp)
}

// GetRegistryNamespaceWithResponse request returning *GetRegistryNamespaceResponse
func (c *ClientWithResponses) GetRegistryNamespaceWithResponse(ctx context.Context, registryName string, namespaceName string, reqEditors ...RequestEditorFn) (*GetRegistryNamespaceResponse, error) {
	rsp, err := c.GetRegistryNamespace(ctx, registryName, namespaceName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryNamespaceResponse(rsp)
}

// GetRegistryNamespacePackagesWithResponse request returning *GetRegistryNamespacePackagesResponse
func (c *ClientWithResponses) GetRegistryNamespacePackagesWithResponse(ctx context.Context, registryName string, namespaceName string, params *GetRegistryNamespacePackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryNamespacePackagesResponse, error) {
	rsp, err := c.GetRegistryNamespacePackages(ctx, registryName, namespaceName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryNamespacePackagesResponse(rsp)
}

// GetRegistryPackageNamesWithResponse request returning *GetRegistryPackageNamesResponse
func (c *ClientWithResponses) GetRegistryPackageNamesWithResponse(ctx context.Context, registryName string, params *GetRegistryPackageNamesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageNamesResponse, error) {
	rsp, err := c.GetRegistryPackageNames(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageNamesResponse(rsp)
}

// GetRegistryPackagesWithResponse request returning *GetRegistryPackagesResponse
func (c *ClientWithResponses) GetRegistryPackagesWithResponse(ctx context.Context, registryName string, params *GetRegistryPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackagesResponse, error) {
	rsp, err := c.GetRegistryPackages(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackagesResponse(rsp)
}

// GetRegistryPackageWithResponse request returning *GetRegistryPackageResponse
func (c *ClientWithResponses) GetRegistryPackageWithResponse(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*GetRegistryPackageResponse, error) {
	rsp, err := c.GetRegistryPackage(ctx, registryName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageResponse(rsp)
}

// GetRegistryPackageDependentPackageKindsWithResponse request returning *GetRegistryPackageDependentPackageKindsResponse
func (c *ClientWithResponses) GetRegistryPackageDependentPackageKindsWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackageKindsParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageDependentPackageKindsResponse, error) {
	rsp, err := c.GetRegistryPackageDependentPackageKinds(ctx, registryName, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageDependentPackageKindsResponse(rsp)
}

// GetRegistryPackageDependentPackagesWithResponse request returning *GetRegistryPackageDependentPackagesResponse
func (c *ClientWithResponses) GetRegistryPackageDependentPackagesWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageDependentPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageDependentPackagesResponse, error) {
	rsp, err := c.GetRegistryPackageDependentPackages(ctx, registryName, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageDependentPackagesResponse(rsp)
}

// GetRegistryPackageRelatedPackagesWithResponse request returning *GetRegistryPackageRelatedPackagesResponse
func (c *ClientWithResponses) GetRegistryPackageRelatedPackagesWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageRelatedPackagesParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageRelatedPackagesResponse, error) {
	rsp, err := c.GetRegistryPackageRelatedPackages(ctx, registryName, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageRelatedPackagesResponse(rsp)
}

// GetRegistryPackageVersionNumbersWithResponse request returning *GetRegistryPackageVersionNumbersResponse
func (c *ClientWithResponses) GetRegistryPackageVersionNumbersWithResponse(ctx context.Context, registryName string, packageName string, reqEditors ...RequestEditorFn) (*GetRegistryPackageVersionNumbersResponse, error) {
	rsp, err := c.GetRegistryPackageVersionNumbers(ctx, registryName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageVersionNumbersResponse(rsp)
}

// GetRegistryPackageVersionsWithResponse request returning *GetRegistryPackageVersionsResponse
func (c *ClientWithResponses) GetRegistryPackageVersionsWithResponse(ctx context.Context, registryName string, packageName string, params *GetRegistryPackageVersionsParams, reqEditors ...RequestEditorFn) (*GetRegistryPackageVersionsResponse, error) {
	rsp, err := c.GetRegistryPackageVersions(ctx, registryName, packageName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageVersionsResponse(rsp)
}

// GetRegistryPackageVersionWithResponse request returning *GetRegistryPackageVersionResponse
func (c *ClientWithResponses) GetRegistryPackageVersionWithResponse(ctx context.Context, registryName string, packageName string, versionNumber string, reqEditors ...RequestEditorFn) (*GetRegistryPackageVersionResponse, error) {
	rsp, err := c.GetRegistryPackageVersion(ctx, registryName, packageName, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryPackageVersionResponse(rsp)
}

// GetRegistryRecentVersionsWithResponse request returning *GetRegistryRecentVersionsResponse
func (c *ClientWithResponses) GetRegistryRecentVersionsWithResponse(ctx context.Context, registryName string, params *GetRegistryRecentVersionsParams, reqEditors ...RequestEditorFn) (*GetRegistryRecentVersionsResponse, error) {
	rsp, err := c.GetRegistryRecentVersions(ctx, registryName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRegistryRecentVersionsResponse(rsp)
}

// ParseGetDependenciesResponse parses an HTTP response from a GetDependenciesWithResponse call
func ParseGetDependenciesResponse(rsp *http.Response) (*GetDependenciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDependenciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Dependency
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetKeywordsResponse parses an HTTP response from a GetKeywordsWithResponse call
func ParseGetKeywordsResponse(rsp *http.Response) (*GetKeywordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeywordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Keyword
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetKeywordResponse parses an HTTP response from a GetKeywordWithResponse call
func ParseGetKeywordResponse(rsp *http.Response) (*GetKeywordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeywordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeywordWithPackages
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLookupPackageResponse parses an HTTP response from a LookupPackageWithResponse call
func ParseLookupPackageResponse(rsp *http.Response) (*LookupPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageWithRegistry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistriesResponse parses an HTTP response from a GetRegistriesWithResponse call
func ParseGetRegistriesResponse(rsp *http.Response) (*GetRegistriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Registry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryResponse parses an HTTP response from a GetRegistryWithResponse call
func ParseGetRegistryResponse(rsp *http.Response) (*GetRegistryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Registry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLookupRegistryPackageResponse parses an HTTP response from a LookupRegistryPackageWithResponse call
func ParseLookupRegistryPackageResponse(rsp *http.Response) (*LookupRegistryPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LookupRegistryPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageWithRegistry
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryMaintainersResponse parses an HTTP response from a GetRegistryMaintainersWithResponse call
func ParseGetRegistryMaintainersResponse(rsp *http.Response) (*GetRegistryMaintainersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryMaintainersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Maintainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryMaintainerResponse parses an HTTP response from a GetRegistryMaintainerWithResponse call
func ParseGetRegistryMaintainerResponse(rsp *http.Response) (*GetRegistryMaintainerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryMaintainerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Maintainer
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryMaintainerPackagesResponse parses an HTTP response from a GetRegistryMaintainerPackagesWithResponse call
func ParseGetRegistryMaintainerPackagesResponse(rsp *http.Response) (*GetRegistryMaintainerPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryMaintainerPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryNamespacesResponse parses an HTTP response from a GetRegistryNamespacesWithResponse call
func ParseGetRegistryNamespacesResponse(rsp *http.Response) (*GetRegistryNamespacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryNamespacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Namespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryNamespaceResponse parses an HTTP response from a GetRegistryNamespaceWithResponse call
func ParseGetRegistryNamespaceResponse(rsp *http.Response) (*GetRegistryNamespaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryNamespaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Namespace
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryNamespacePackagesResponse parses an HTTP response from a GetRegistryNamespacePackagesWithResponse call
func ParseGetRegistryNamespacePackagesResponse(rsp *http.Response) (*GetRegistryNamespacePackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryNamespacePackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageNamesResponse parses an HTTP response from a GetRegistryPackageNamesWithResponse call
func ParseGetRegistryPackageNamesResponse(rsp *http.Response) (*GetRegistryPackageNamesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageNamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackagesResponse parses an HTTP response from a GetRegistryPackagesWithResponse call
func ParseGetRegistryPackagesResponse(rsp *http.Response) (*GetRegistryPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageResponse parses an HTTP response from a GetRegistryPackageWithResponse call
func ParseGetRegistryPackageResponse(rsp *http.Response) (*GetRegistryPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageDependentPackageKindsResponse parses an HTTP response from a GetRegistryPackageDependentPackageKindsWithResponse call
func ParseGetRegistryPackageDependentPackageKindsResponse(rsp *http.Response) (*GetRegistryPackageDependentPackageKindsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageDependentPackageKindsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageDependentPackagesResponse parses an HTTP response from a GetRegistryPackageDependentPackagesWithResponse call
func ParseGetRegistryPackageDependentPackagesResponse(rsp *http.Response) (*GetRegistryPackageDependentPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageDependentPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageRelatedPackagesResponse parses an HTTP response from a GetRegistryPackageRelatedPackagesWithResponse call
func ParseGetRegistryPackageRelatedPackagesResponse(rsp *http.Response) (*GetRegistryPackageRelatedPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageRelatedPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Package
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageVersionNumbersResponse parses an HTTP response from a GetRegistryPackageVersionNumbersWithResponse call
func ParseGetRegistryPackageVersionNumbersResponse(rsp *http.Response) (*GetRegistryPackageVersionNumbersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageVersionNumbersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageVersionsResponse parses an HTTP response from a GetRegistryPackageVersionsWithResponse call
func ParseGetRegistryPackageVersionsResponse(rsp *http.Response) (*GetRegistryPackageVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Version
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryPackageVersionResponse parses an HTTP response from a GetRegistryPackageVersionWithResponse call
func ParseGetRegistryPackageVersionResponse(rsp *http.Response) (*GetRegistryPackageVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryPackageVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest VersionWithDependencies
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRegistryRecentVersionsResponse parses an HTTP response from a GetRegistryRecentVersionsWithResponse call
func ParseGetRegistryRecentVersionsResponse(rsp *http.Response) (*GetRegistryRecentVersionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRegistryRecentVersionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []VersionWithPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
