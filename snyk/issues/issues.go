// Package issues provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package issues

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	APITokenScopes   = "APIToken.Scopes"
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ClassTypeDef.
const (
	Compliance   ClassTypeDef = "compliance"
	RuleCategory ClassTypeDef = "rule-category"
	Weakness     ClassTypeDef = "weakness"
)

// Defines values for CommonIssueModelVThreeAttributesEffectiveSeverityLevel.
const (
	CommonIssueModelVThreeAttributesEffectiveSeverityLevelCritical CommonIssueModelVThreeAttributesEffectiveSeverityLevel = "critical"
	CommonIssueModelVThreeAttributesEffectiveSeverityLevelHigh     CommonIssueModelVThreeAttributesEffectiveSeverityLevel = "high"
	CommonIssueModelVThreeAttributesEffectiveSeverityLevelInfo     CommonIssueModelVThreeAttributesEffectiveSeverityLevel = "info"
	CommonIssueModelVThreeAttributesEffectiveSeverityLevelLow      CommonIssueModelVThreeAttributesEffectiveSeverityLevel = "low"
	CommonIssueModelVThreeAttributesEffectiveSeverityLevelMedium   CommonIssueModelVThreeAttributesEffectiveSeverityLevel = "medium"
)

// Defines values for IgnoreType.
const (
	Ignore IgnoreType = "ignore"
)

// Defines values for IssueAttributesCoordinatesReachability.
const (
	Function      IssueAttributesCoordinatesReachability = "function"
	NoInfo        IssueAttributesCoordinatesReachability = "no-info"
	NotApplicable IssueAttributesCoordinatesReachability = "not-applicable"
	Package       IssueAttributesCoordinatesReachability = "package"
)

// Defines values for IssueAttributesCoordinatesRemediesType.
const (
	IssueAttributesCoordinatesRemediesTypeArm               IssueAttributesCoordinatesRemediesType = "arm"
	IssueAttributesCoordinatesRemediesTypeAutomated         IssueAttributesCoordinatesRemediesType = "automated"
	IssueAttributesCoordinatesRemediesTypeCli               IssueAttributesCoordinatesRemediesType = "cli"
	IssueAttributesCoordinatesRemediesTypeCloudformation    IssueAttributesCoordinatesRemediesType = "cloudformation"
	IssueAttributesCoordinatesRemediesTypeIndeterminate     IssueAttributesCoordinatesRemediesType = "indeterminate"
	IssueAttributesCoordinatesRemediesTypeKubernetes        IssueAttributesCoordinatesRemediesType = "kubernetes"
	IssueAttributesCoordinatesRemediesTypeManual            IssueAttributesCoordinatesRemediesType = "manual"
	IssueAttributesCoordinatesRemediesTypeRuleResultMessage IssueAttributesCoordinatesRemediesType = "rule_result_message"
	IssueAttributesCoordinatesRemediesTypeTerraform         IssueAttributesCoordinatesRemediesType = "terraform"
)

// Defines values for IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType.
const (
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeAws     IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "aws"
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeAzure   IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "azure"
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeAzureAd IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "azure_ad"
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeCli     IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "cli"
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeGoogle  IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "google"
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeScm     IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "scm"
	IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentTypeTfc     IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType = "tfc"
)

// Defines values for IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType.
const (
	Arm       IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "arm"
	Cfn       IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "cfn"
	CloudScan IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "cloud_scan"
	K8s       IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "k8s"
	Tf        IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "tf"
	TfHcl     IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "tf_hcl"
	TfPlan    IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "tf_plan"
	TfState   IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType = "tf_state"
)

// Defines values for IssueAttributesCoordinatesRepresentations2CloudResourceResourceType.
const (
	IssueAttributesCoordinatesRepresentations2CloudResourceResourceTypeCloud IssueAttributesCoordinatesRepresentations2CloudResourceResourceType = "cloud"
	IssueAttributesCoordinatesRepresentations2CloudResourceResourceTypeIac   IssueAttributesCoordinatesRepresentations2CloudResourceResourceType = "iac"
)

// Defines values for IssueAttributesEffectiveSeverityLevel.
const (
	IssueAttributesEffectiveSeverityLevelCritical IssueAttributesEffectiveSeverityLevel = "critical"
	IssueAttributesEffectiveSeverityLevelHigh     IssueAttributesEffectiveSeverityLevel = "high"
	IssueAttributesEffectiveSeverityLevelInfo     IssueAttributesEffectiveSeverityLevel = "info"
	IssueAttributesEffectiveSeverityLevelLow      IssueAttributesEffectiveSeverityLevel = "low"
	IssueAttributesEffectiveSeverityLevelMedium   IssueAttributesEffectiveSeverityLevel = "medium"
)

// Defines values for IssueAttributesStatus.
const (
	IssueAttributesStatusOpen     IssueAttributesStatus = "open"
	IssueAttributesStatusResolved IssueAttributesStatus = "resolved"
)

// Defines values for IssueType.
const (
	IssueTypeIssue IssueType = "issue"
)

// Defines values for OrganizationType.
const (
	Organization OrganizationType = "organization"
)

// Defines values for ProblemTypeDef.
const (
	Rule          ProblemTypeDef = "rule"
	Vulnerability ProblemTypeDef = "vulnerability"
)

// Defines values for ResolutionTypeDef.
const (
	Disappeared ResolutionTypeDef = "disappeared"
	Fixed       ResolutionTypeDef = "fixed"
)

// Defines values for ScanItemType.
const (
	Environment ScanItemType = "environment"
	Project     ScanItemType = "project"
)

// Defines values for TestExecutionType.
const (
	CustomExecution       TestExecutionType = "custom-execution"
	TestWorkflowExecution TestExecutionType = "test-workflow-execution"
)

// Defines values for TypeDef.
const (
	TypeDefCloud                TypeDef = "cloud"
	TypeDefCode                 TypeDef = "code"
	TypeDefConfig               TypeDef = "config"
	TypeDefCustom               TypeDef = "custom"
	TypeDefLicense              TypeDef = "license"
	TypeDefPackageVulnerability TypeDef = "package_vulnerability"
)

// Defines values for ListGroupIssuesParamsEffectiveSeverityLevel.
const (
	ListGroupIssuesParamsEffectiveSeverityLevelCritical ListGroupIssuesParamsEffectiveSeverityLevel = "critical"
	ListGroupIssuesParamsEffectiveSeverityLevelHigh     ListGroupIssuesParamsEffectiveSeverityLevel = "high"
	ListGroupIssuesParamsEffectiveSeverityLevelInfo     ListGroupIssuesParamsEffectiveSeverityLevel = "info"
	ListGroupIssuesParamsEffectiveSeverityLevelLow      ListGroupIssuesParamsEffectiveSeverityLevel = "low"
	ListGroupIssuesParamsEffectiveSeverityLevelMedium   ListGroupIssuesParamsEffectiveSeverityLevel = "medium"
)

// Defines values for ListGroupIssuesParamsStatus.
const (
	ListGroupIssuesParamsStatusOpen     ListGroupIssuesParamsStatus = "open"
	ListGroupIssuesParamsStatusResolved ListGroupIssuesParamsStatus = "resolved"
)

// Defines values for ListOrgIssuesParamsEffectiveSeverityLevel.
const (
	ListOrgIssuesParamsEffectiveSeverityLevelCritical ListOrgIssuesParamsEffectiveSeverityLevel = "critical"
	ListOrgIssuesParamsEffectiveSeverityLevelHigh     ListOrgIssuesParamsEffectiveSeverityLevel = "high"
	ListOrgIssuesParamsEffectiveSeverityLevelInfo     ListOrgIssuesParamsEffectiveSeverityLevel = "info"
	ListOrgIssuesParamsEffectiveSeverityLevelLow      ListOrgIssuesParamsEffectiveSeverityLevel = "low"
	ListOrgIssuesParamsEffectiveSeverityLevelMedium   ListOrgIssuesParamsEffectiveSeverityLevel = "medium"
)

// Defines values for ListOrgIssuesParamsStatus.
const (
	Open     ListOrgIssuesParamsStatus = "open"
	Resolved ListOrgIssuesParamsStatus = "resolved"
)

// ActualVersion Resolved API version
type ActualVersion = string

// BulkPackageUrlsRequestBody defines model for BulkPackageUrlsRequestBody.
type BulkPackageUrlsRequestBody struct {
	Data struct {
		Attributes struct {
			// Purls An array of Package URLs (purl). Supported purl types are apk, cargo, cocoapods, composer, deb, gem, generic, golang, hex, maven, npm, nuget, pub, pypi, rpm, and swift. A version for the package is also required.
			Purls []string `json:"purls"`
		} `json:"attributes"`
		Type *Types `json:"type,omitempty"`
	} `json:"data"`
}

// CVSSSource defines model for CVSSSource.
type CVSSSource struct {
	Level string `json:"level"`

	// ModificationTime The time this CVSS data was last updated
	ModificationTime time.Time `json:"modification_time"`
	Score            float32   `json:"score"`
	Source           string    `json:"source"`
	Vector           string    `json:"vector"`
	Version          string    `json:"version"`
}

// Class defines model for Class.
type Class struct {
	Id     string       `json:"id"`
	Source string       `json:"source"`
	Type   ClassTypeDef `json:"type"`

	// Url An optional URL for this class.
	Url *string `json:"url,omitempty"`
}

// ClassTypeDef defines model for ClassTypeDef.
type ClassTypeDef string

// CommonIssueModelVThree defines model for CommonIssueModelVThree.
type CommonIssueModelVThree struct {
	Attributes *struct {
		Coordinates *[]Coordinate `json:"coordinates,omitempty"`
		CreatedAt   *time.Time    `json:"created_at,omitempty"`

		// Description A description of the issue in Markdown format
		Description *string `json:"description,omitempty"`

		// EffectiveSeverityLevel The type from enumeration of the issue’s severity level. This is usually set from the issue’s producer, but can be overridden by policies.
		EffectiveSeverityLevel *CommonIssueModelVThreeAttributesEffectiveSeverityLevel `json:"effective_severity_level,omitempty"`
		Problems               *[]Problem3                                             `json:"problems,omitempty"`

		// Severities An array of dictionaries containing all known data related to the vulnerability
		Severities *[]Severity3 `json:"severities,omitempty"`
		Slots      *Slots       `json:"slots,omitempty"`

		// Title A human-readable title for this issue.
		Title *string `json:"title,omitempty"`

		// Type The issue type
		Type *string `json:"type,omitempty"`

		// UpdatedAt When the vulnerability information was last modified.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`
	} `json:"attributes,omitempty"`

	// Id The Snyk ID of the vulnerability.
	Id *string `json:"id,omitempty"`

	// Type The type of the REST resource. Always ‘issue’.
	Type *string `json:"type,omitempty"`
}

// CommonIssueModelVThreeAttributesEffectiveSeverityLevel The type from enumeration of the issue’s severity level. This is usually set from the issue’s producer, but can be overridden by policies.
type CommonIssueModelVThreeAttributesEffectiveSeverityLevel string

// Coordinate defines model for Coordinate.
type Coordinate struct {
	Remedies *[]Remedy3 `json:"remedies,omitempty"`

	// Representations The affected versions of this vulnerability.
	Representations []Coordinate_Representations_Item `json:"representations"`
}

// Coordinate_Representations_Item defines model for Coordinate.representations.Item.
type Coordinate_Representations_Item struct {
	union json.RawMessage
}

// DeployedRiskFactor defines model for DeployedRiskFactor.
type DeployedRiskFactor struct {
	IncludedInScore *bool            `json:"included_in_score,omitempty"`
	Links           *RiskFactorLinks `json:"links,omitempty"`
	Name            string           `json:"name"`
	UpdatedAt       time.Time        `json:"updated_at"`
	Value           bool             `json:"value"`
}

// Error defines model for Error.
type Error struct {
	// Code An application-specific error code, expressed as a string value.
	Code *string `json:"code,omitempty"`

	// Detail A human-readable explanation specific to this occurrence of the problem.
	Detail string `json:"detail"`

	// Id A unique identifier for this particular occurrence of the problem.
	Id *openapi_types.UUID `json:"id,omitempty"`

	// Links A link that leads to further details about this particular occurrance of the problem.
	Links  *ErrorLink              `json:"links,omitempty"`
	Meta   *map[string]interface{} `json:"meta,omitempty"`
	Source *struct {
		// Parameter A string indicating which URI query parameter caused the error.
		Parameter *string `json:"parameter,omitempty"`

		// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
		Pointer *string `json:"pointer,omitempty"`
	} `json:"source,omitempty"`

	// Status The HTTP status code applicable to this problem, expressed as a string value.
	Status string `json:"status"`

	// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `json:"title,omitempty"`
}

// ErrorDocument defines model for ErrorDocument.
type ErrorDocument struct {
	Errors  []Error `json:"errors"`
	Jsonapi JsonApi `json:"jsonapi"`
}

// ErrorLink A link that leads to further details about this particular occurrance of the problem.
type ErrorLink struct {
	About *LinkProperty `json:"about,omitempty"`
}

// ExploitDetails Details about the exploits
type ExploitDetails struct {
	// MaturityLevels List of maturity levels
	MaturityLevels *[]MaturityLevel `json:"maturity_levels,omitempty"`

	// Sources Sources for determining exploit maturity level, e.g., CISA, ExploitDB, Snyk.
	Sources *[]string `json:"sources,omitempty"`
}

// IgnoreType defines model for IgnoreType.
type IgnoreType string

// Issue A Snyk Issue.
type Issue struct {
	// Attributes issue attributes
	Attributes IssueAttributes    `json:"attributes"`
	Id         openapi_types.UUID `json:"id"`

	// Relationships issue relationships
	Relationships IssueRelationships `json:"relationships"`
	Type          IssueType          `json:"type"`
}

// IssueAttributes issue attributes
type IssueAttributes struct {
	// Classes A list of details for weakness data, policy, etc that are the class of this issue's source.
	Classes *[]Class `json:"classes,omitempty"`

	// Coordinates Where the issue originated, specific to issue type. Details on what
	// code, package, etc introduced the issue. An issue may be caused by
	// more than one coordinate.
	Coordinates *[]struct {
		IsFixableManually *bool                                   `json:"is_fixable_manually,omitempty"`
		IsFixableSnyk     *bool                                   `json:"is_fixable_snyk,omitempty"`
		IsFixableUpstream *bool                                   `json:"is_fixable_upstream,omitempty"`
		IsPatchable       *bool                                   `json:"is_patchable,omitempty"`
		IsPinnable        *bool                                   `json:"is_pinnable,omitempty"`
		IsUpgradeable     *bool                                   `json:"is_upgradeable,omitempty"`
		Reachability      *IssueAttributesCoordinatesReachability `json:"reachability,omitempty"`
		Remedies          *[]struct {
			// CorrelationId An optional identifier for correlating remedies between coordinates or across issues. They are scoped
			// to a single Project and test run. Remedies with the same correlation_id must have the same contents.
			CorrelationId *string `json:"correlation_id,omitempty"`

			// Description A markdown-formatted optional description of this remedy. Links are not permitted.
			Description *string `json:"description,omitempty"`
			Meta        *struct {
				// Data Metadata information related to apply a remedy. Limited in size to 100Kb when JSON serialized.
				Data map[string]interface{} `json:"data"`

				// SchemaVersion A schema version identifier the metadata object validates against. Note: this information is
				// only relevant in the domain of the API consumer: the issues system always considers metadata
				// just as an arbitrary object.
				SchemaVersion string `json:"schema_version"`
			} `json:"meta,omitempty"`
			Type IssueAttributesCoordinatesRemediesType `json:"type"`
		} `json:"remedies,omitempty"`

		// Representations A list of precise locations that surface an issue. A coordinate may have multiple representations.
		Representations *[]IssueAttributes_Coordinates_Representations_Item `json:"representations,omitempty"`
	} `json:"coordinates,omitempty"`

	// CreatedAt The creation time of this issue.
	CreatedAt time.Time `json:"created_at"`

	// Description A markdown-formatted optional description of this issue. Links are not permitted.
	Description *string `json:"description,omitempty"`

	// EffectiveSeverityLevel The computed effective severity of this issue. This is either the highest level from all included severities,
	// or an overridden value set via group level policy.
	EffectiveSeverityLevel IssueAttributesEffectiveSeverityLevel `json:"effective_severity_level"`
	ExploitDetails         *struct {
		MaturityLevels []struct {
			Format string `json:"format"`
			Level  string `json:"level"`
		} `json:"maturity_levels"`
		Sources []string `json:"sources"`
	} `json:"exploit_details,omitempty"`

	// Ignored A flag indicating if the issue is being ignored. Derived from the issue's ignore, which provides more details.
	Ignored bool `json:"ignored"`

	// Key An opaque key used for uniquely identifying this issue across test runs, within a project.
	Key string `json:"key"`

	// Problems A list of details for vulnerability data, policy, etc that are the source of this issue.
	Problems *[]Problem `json:"problems,omitempty"`

	// Resolution An optional field recording when and via what means an issue was resolved, if it was resolved.
	// Resolved issues are retained for XX days.
	Resolution *Resolution `json:"resolution,omitempty"`

	// Risk Risk prioritization information for an issue
	Risk       *Risk         `json:"risk,omitempty"`
	Severities *[]CVSSSource `json:"severities,omitempty"`

	// Status The issue's status. Derived from the issue's resolution, which provides more details.
	Status IssueAttributesStatus `json:"status"`

	// Title A human-readable title for this issue.
	Title string `json:"title"`

	// Tool An opaque identifier for corelating across test runs.
	Tool *string `json:"tool,omitempty"`

	// Type The type of an issue.
	Type TypeDef `json:"type"`

	// UpdatedAt The time when this issue was last modified.
	UpdatedAt time.Time `json:"updated_at"`
}

// IssueAttributesCoordinatesReachability defines model for IssueAttributes.Coordinates.Reachability.
type IssueAttributesCoordinatesReachability string

// IssueAttributesCoordinatesRemediesType defines model for IssueAttributes.Coordinates.Remedies.Type.
type IssueAttributesCoordinatesRemediesType string

// IssueAttributesCoordinatesRepresentations0 An object that contains an opaque identifying string.
type IssueAttributesCoordinatesRepresentations0 struct {
	ResourcePath string `json:"resourcePath"`
}

// IssueAttributesCoordinatesRepresentations1 An object that contains a list of opaque identifying strings.
type IssueAttributesCoordinatesRepresentations1 struct {
	Dependency struct {
		// PackageName The package name the issue was found in
		PackageName string `json:"package_name"`

		// PackageVersion The package version the issue was found in
		PackageVersion string `json:"package_version"`
	} `json:"dependency"`
}

// IssueAttributesCoordinatesRepresentations2 A resource location to some service, like a cloud resource.
type IssueAttributesCoordinatesRepresentations2 struct {
	CloudResource struct {
		Environment struct {
			// Id Internal ID for an environment.
			Id   openapi_types.UUID `json:"id"`
			Name string             `json:"name"`

			// NativeId An optional native identifier for this environment. For example, a cloud account id.
			NativeId *string                                                                `json:"native_id,omitempty"`
			Type     IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType `json:"type"`
		} `json:"environment"`
		Resource *struct {
			// IacMappingsCount Amount of IaC resources this resource maps to.
			IacMappingsCount *int64 `json:"iac_mappings_count,omitempty"`

			// Id Internal ID for a resource.
			Id        *openapi_types.UUID                                                      `json:"id,omitempty"`
			InputType IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType `json:"input_type"`
			Location  *string                                                                  `json:"location,omitempty"`
			Name      *string                                                                  `json:"name,omitempty"`

			// NativeId An optional native identifier for this resource. For example, a cloud resource id.
			NativeId     *string                                                              `json:"native_id,omitempty"`
			Platform     *string                                                              `json:"platform,omitempty"`
			ResourceType *string                                                              `json:"resource_type,omitempty"`
			Tags         *map[string]string                                                   `json:"tags,omitempty"`
			Type         *IssueAttributesCoordinatesRepresentations2CloudResourceResourceType `json:"type,omitempty"`
		} `json:"resource,omitempty"`
	} `json:"cloud_resource"`
}

// IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType defines model for IssueAttributes.Coordinates.Representations.2.CloudResource.Environment.Type.
type IssueAttributesCoordinatesRepresentations2CloudResourceEnvironmentType string

// IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType defines model for IssueAttributes.Coordinates.Representations.2.CloudResource.Resource.InputType.
type IssueAttributesCoordinatesRepresentations2CloudResourceResourceInputType string

// IssueAttributesCoordinatesRepresentations2CloudResourceResourceType defines model for IssueAttributes.Coordinates.Representations.2.CloudResource.Resource.Type.
type IssueAttributesCoordinatesRepresentations2CloudResourceResourceType string

// IssueAttributesCoordinatesRepresentations3 A location within a file.
type IssueAttributesCoordinatesRepresentations3 struct {
	SourceLocation struct {
		// File A path to the file containing this issue, relative to the root of the project target,
		// formatted using POSIX separators.
		File   string `json:"file"`
		Region *struct {
			End struct {
				Column int `json:"column"`
				Line   int `json:"line"`
			} `json:"end"`
			Start struct {
				Column int `json:"column"`
				Line   int `json:"line"`
			} `json:"start"`
		} `json:"region,omitempty"`
	} `json:"sourceLocation"`
}

// IssueAttributes_Coordinates_Representations_Item defines model for IssueAttributes.Coordinates.Representations.Item.
type IssueAttributes_Coordinates_Representations_Item struct {
	union json.RawMessage
}

// IssueAttributesEffectiveSeverityLevel The computed effective severity of this issue. This is either the highest level from all included severities,
// or an overridden value set via group level policy.
type IssueAttributesEffectiveSeverityLevel string

// IssueAttributesStatus The issue's status. Derived from the issue's resolution, which provides more details.
type IssueAttributesStatus string

// IssueRelationships issue relationships
type IssueRelationships struct {
	// Ignore An optional reference to an ignore rule that marks this issue as ignored.
	Ignore *struct {
		Data struct {
			Id   string     `json:"id"`
			Type IgnoreType `json:"type"`
		} `json:"data"`
	} `json:"ignore,omitempty"`
	Organization struct {
		Data struct {
			Id   openapi_types.UUID `json:"id"`
			Type OrganizationType   `json:"type"`
		} `json:"data"`
	} `json:"organization"`
	ScanItem struct {
		Data struct {
			Id   openapi_types.UUID `json:"id"`
			Type ScanItemType       `json:"type"`
		} `json:"data"`
	} `json:"scan_item"`

	// TestExecutions The "test execution" that identified this Issues. This ID represents
	// a grouping of issues, that were identified by some analysis run, to produce
	// Issues.
	TestExecutions *struct {
		// Data List of metadata associated with the test executions that identified this issue
		Data []struct {
			Id   string            `json:"id"`
			Type TestExecutionType `json:"type"`
		} `json:"data"`
	} `json:"test_executions,omitempty"`
}

// IssueType defines model for IssueType.
type IssueType string

// IssuesMeta defines model for IssuesMeta.
type IssuesMeta struct {
	Package *PackageMeta `json:"package,omitempty"`
}

// IssuesResponse defines model for IssuesResponse.
type IssuesResponse struct {
	Data    *[]CommonIssueModelVThree `json:"data,omitempty"`
	Jsonapi *JsonApi                  `json:"jsonapi,omitempty"`
	Links   *PaginatedLinks           `json:"links,omitempty"`
	Meta    *IssuesMeta               `json:"meta,omitempty"`
}

// IssuesWithPurlsResponse defines model for IssuesWithPurlsResponse.
type IssuesWithPurlsResponse struct {
	Data    *[]CommonIssueModelVThree `json:"data,omitempty"`
	Jsonapi *JsonApi                  `json:"jsonapi,omitempty"`
	Links   *PaginatedLinks           `json:"links,omitempty"`
	Meta    *struct {
		Errors *[]Error `json:"errors,omitempty"`
	} `json:"meta,omitempty"`
}

// JsonApi defines model for JsonApi.
type JsonApi struct {
	// Version Version of the JSON API specification this server supports.
	Version string `json:"version"`
}

// LinkProperty defines model for LinkProperty.
type LinkProperty struct {
	union json.RawMessage
}

// LinkProperty0 A string containing the link’s URL.
type LinkProperty0 = string

// LinkProperty1 defines model for .
type LinkProperty1 struct {
	// Href A string containing the link’s URL.
	Href string `json:"href"`

	// Meta Free-form object that may contain non-standard information.
	Meta *Meta `json:"meta,omitempty"`
}

// LoadedPackageRiskFactor defines model for LoadedPackageRiskFactor.
type LoadedPackageRiskFactor struct {
	IncludedInScore *bool            `json:"included_in_score,omitempty"`
	Links           *RiskFactorLinks `json:"links,omitempty"`
	Name            string           `json:"name"`
	UpdatedAt       time.Time        `json:"updated_at"`
	Value           bool             `json:"value"`
}

// MaturityLevel Details about the maturity level
type MaturityLevel struct {
	// Format The standard by which the “maturity” value is shown.
	Format *string `json:"format,omitempty"`

	// Level Exploit maturity of the vulnerability. For CVSSv3: Proof of Concept, Functional, High. For CVSSv4: Unreported, Proof of Concept, Attacked.
	Level *string `json:"level,omitempty"`

	// Type Indicates if the CVSS item is primary or secondary. Clients should prefer the primary CVSS vector.
	Type *string `json:"type,omitempty"`
}

// Meta Free-form object that may contain non-standard information.
type Meta map[string]interface{}

// OSConditionRiskFactor defines model for OSConditionRiskFactor.
type OSConditionRiskFactor struct {
	IncludedInScore *bool            `json:"included_in_score,omitempty"`
	Links           *RiskFactorLinks `json:"links,omitempty"`
	Name            string           `json:"name"`
	UpdatedAt       time.Time        `json:"updated_at"`
	Value           bool             `json:"value"`
}

// OrganizationType defines model for OrganizationType.
type OrganizationType string

// PackageMeta defines model for PackageMeta.
type PackageMeta struct {
	// Name The package’s name
	Name *string `json:"name,omitempty"`

	// Namespace A name prefix, such as a maven group id or docker image owner
	Namespace *string `json:"namespace,omitempty"`

	// Type The package type or protocol
	Type *string `json:"type,omitempty"`

	// Url The purl of the package
	Url *string `json:"url,omitempty"`

	// Version The version of the package
	Version *string `json:"version,omitempty"`
}

// PackageRepresentation defines model for PackageRepresentation.
type PackageRepresentation struct {
	Package *PackageMeta `json:"package,omitempty"`
}

// PaginatedLinks defines model for PaginatedLinks.
type PaginatedLinks struct {
	First *LinkProperty `json:"first,omitempty"`
	Last  *LinkProperty `json:"last,omitempty"`
	Next  *LinkProperty `json:"next,omitempty"`
	Prev  *LinkProperty `json:"prev,omitempty"`
	Self  *LinkProperty `json:"self,omitempty"`
}

// Problem defines model for Problem.
type Problem struct {
	// DisclosedAt When this problem was disclosed to the public.
	DisclosedAt *time.Time `json:"disclosed_at,omitempty"`

	// DiscoveredAt When this problem was first discovered.
	DiscoveredAt *time.Time     `json:"discovered_at,omitempty"`
	Id           string         `json:"id"`
	Source       string         `json:"source"`
	Type         ProblemTypeDef `json:"type"`

	// UpdatedAt When this problem was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url An optional URL for this problem.
	Url *string `json:"url,omitempty"`
}

// Problem3 defines model for Problem3.
type Problem3 struct {
	// DisclosedAt When this problem was disclosed to the public.
	DisclosedAt *time.Time `json:"disclosed_at,omitempty"`

	// DiscoveredAt When this problem was first discovered.
	DiscoveredAt *time.Time `json:"discovered_at,omitempty"`
	Id           string     `json:"id"`
	Source       string     `json:"source"`

	// UpdatedAt When this problem was last updated.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Url An optional URL for this problem.
	Url *string `json:"url,omitempty"`
}

// ProblemTypeDef defines model for ProblemTypeDef.
type ProblemTypeDef string

// PublicFacingRiskFactor defines model for PublicFacingRiskFactor.
type PublicFacingRiskFactor struct {
	IncludedInScore *bool            `json:"included_in_score,omitempty"`
	Links           *RiskFactorLinks `json:"links,omitempty"`
	Name            string           `json:"name"`
	UpdatedAt       time.Time        `json:"updated_at"`
	Value           bool             `json:"value"`
}

// QueryVersion Requested API version
type QueryVersion = string

// Remedy3 defines model for Remedy3.
type Remedy3 struct {
	// Description A markdown-formatted optional description of this remedy.
	Description *string `json:"description,omitempty"`
	Details     *struct {
		// UpgradePackage A minimum version to upgrade to in order to remedy the issue.
		UpgradePackage *string `json:"upgrade_package,omitempty"`
	} `json:"details,omitempty"`

	// Type The type of the remedy. Always ‘indeterminate’.
	Type *string `json:"type,omitempty"`
}

// Resolution An optional field recording when and via what means an issue was resolved, if it was resolved.
// Resolved issues are retained for XX days.
type Resolution struct {
	// Details Optional details about the resolution. Used by Snyk Cloud so far.
	Details *string `json:"details,omitempty"`

	// ResolvedAt The time when this issue was resolved.
	ResolvedAt time.Time         `json:"resolved_at"`
	Type       ResolutionTypeDef `json:"type"`
}

// ResolutionTypeDef defines model for ResolutionTypeDef.
type ResolutionTypeDef string

// ResourcePath defines model for ResourcePath.
type ResourcePath = string

// ResourcePathRepresentation An object that contains an opaque identifying string.
type ResourcePathRepresentation struct {
	ResourcePath ResourcePath `json:"resource_path"`
}

// Risk Risk prioritization information for an issue
type Risk struct {
	// Factors Risk factors identified for an issue
	Factors []RiskFactor `json:"factors"`

	// Score Risk prioritization score based on an analysis model
	Score *RiskScore `json:"score,omitempty"`
}

// RiskFactor defines model for RiskFactor.
type RiskFactor struct {
	union json.RawMessage
}

// RiskFactorLinks defines model for RiskFactorLinks.
type RiskFactorLinks struct {
	Evidence *LinkProperty `json:"evidence,omitempty"`
}

// RiskScore Risk prioritization score based on an analysis model
type RiskScore struct {
	// Model Risk scoring model used to calculate the score value
	Model     string     `json:"model"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`

	// Value Risk score value, which may be used for overall prioritization
	Value int `json:"value"`
}

// ScanItemType defines model for ScanItemType.
type ScanItemType string

// Severity3 defines model for Severity3.
type Severity3 struct {
	// Level Level of severity calculated via vector
	Level *string `json:"level,omitempty"`

	// Score The CVSS score calculated from the vector, representing the severity of the vulnerability on a scale from 0 to 10.
	Score *float32 `json:"score"`

	// Source The source of this severity. The value must be the id of a referenced problem or class, in which case that problem or class is the source of this issue. If source is omitted, this severity is sourced internally in the Snyk application.
	Source *string `json:"source,omitempty"`

	// Type Indicates if the CVSS item is primary or secondary. Clients should prefer the primary CVSS vector.
	Type *string `json:"type,omitempty"`

	// Vector CVSS vector string detailing the metrics of a vulnerability.
	Vector *string `json:"vector"`

	// Version CVSS version being described.
	Version *string `json:"version,omitempty"`
}

// Slots defines model for Slots.
type Slots struct {
	// DisclosureTime The time at which this vulnerability was disclosed.
	DisclosureTime *time.Time `json:"disclosure_time,omitempty"`

	// ExploitDetails Details about the exploits
	ExploitDetails *ExploitDetails `json:"exploit_details,omitempty"`

	// PublicationTime The time at which this vulnerability was published.
	PublicationTime *string `json:"publication_time,omitempty"`
	References      *[]struct {
		// Title Descriptor for an external reference to the issue
		Title *string `json:"title,omitempty"`

		// Url URL for an external reference to the issue
		Url *string `json:"url,omitempty"`
	} `json:"references,omitempty"`
}

// TestExecutionType defines model for TestExecutionType.
type TestExecutionType string

// TypeDef The type of an issue.
type TypeDef string

// Types defines model for Types.
type Types = string

// CreatedAfter defines model for CreatedAfter.
type CreatedAfter = time.Time

// CreatedBefore defines model for CreatedBefore.
type CreatedBefore = time.Time

// EffectiveSeverityLevel defines model for EffectiveSeverityLevel.
type EffectiveSeverityLevel = []string

// EndingBefore defines model for EndingBefore.
type EndingBefore = string

// Ignored defines model for Ignored.
type Ignored = bool

// Limit defines model for Limit.
type Limit = int32

// OrgId defines model for OrgId.
type OrgId = openapi_types.UUID

// PackageUrl defines model for PackageUrl.
type PackageUrl = string

// PathIssueId20240123 defines model for PathIssueId20240123.
type PathIssueId20240123 = openapi_types.UUID

// ScanItemId defines model for ScanItemId.
type ScanItemId = openapi_types.UUID

// StartingAfter defines model for StartingAfter.
type StartingAfter = string

// Status defines model for Status.
type Status = []string

// Type The type of an issue.
type Type = TypeDef

// UpdatedAfter defines model for UpdatedAfter.
type UpdatedAfter = time.Time

// UpdatedBefore defines model for UpdatedBefore.
type UpdatedBefore = time.Time

// Version Requested API version
type Version = QueryVersion

// N400 defines model for 400.
type N400 = ErrorDocument

// N401 defines model for 401.
type N401 = ErrorDocument

// N403 defines model for 403.
type N403 = ErrorDocument

// N404 defines model for 404.
type N404 = ErrorDocument

// N409 defines model for 409.
type N409 = ErrorDocument

// N500 defines model for 500.
type N500 = ErrorDocument

// GetIssue20020240123 defines model for GetIssue20020240123.
type GetIssue20020240123 struct {
	// Data A Snyk Issue.
	Data    Issue           `json:"data"`
	Jsonapi JsonApi         `json:"jsonapi"`
	Links   *PaginatedLinks `json:"links,omitempty"`
}

// ListIssues200 defines model for ListIssues200.
type ListIssues200 struct {
	Data    []Issue         `json:"data"`
	Jsonapi JsonApi         `json:"jsonapi"`
	Links   *PaginatedLinks `json:"links,omitempty"`
}

// ListGroupIssuesParams defines parameters for ListGroupIssues.
type ListGroupIssuesParams struct {
	// Version The requested version of the endpoint to process the request
	Version Version `form:"version" json:"version"`

	// StartingAfter Return the page of results immediately after this cursor
	StartingAfter *StartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore Return the page of results immediately before this cursor
	EndingBefore *EndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Limit Number of results to return per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// ScanItemId A scan item id to filter issues through their scan item relationship.
	ScanItemId *ScanItemId `form:"scan_item.id,omitempty" json:"scan_item.id,omitempty"`

	// ScanItemType A scan item types to filter issues through their scan item relationship.
	ScanItemType *ScanItemType `form:"scan_item.type,omitempty" json:"scan_item.type,omitempty"`

	// Type An issue type to filter issues.
	Type *Type `form:"type,omitempty" json:"type,omitempty"`

	// UpdatedBefore A filter to select issues updated before this date.
	UpdatedBefore *UpdatedBefore `form:"updated_before,omitempty" json:"updated_before,omitempty"`

	// UpdatedAfter A filter to select issues updated after this date.
	UpdatedAfter *UpdatedAfter `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// CreatedBefore A filter to select issues created before this date.
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// CreatedAfter A filter to select issues created after this date.
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// EffectiveSeverityLevel One or more effective severity levels to filter issues.
	EffectiveSeverityLevel *EffectiveSeverityLevel `form:"effective_severity_level,omitempty" json:"effective_severity_level,omitempty"`

	// Status An issue's status
	Status *Status `form:"status,omitempty" json:"status,omitempty"`

	// Ignored Whether an issue is ignored or not.
	Ignored *Ignored `form:"ignored,omitempty" json:"ignored,omitempty"`
}

// ListGroupIssuesParamsEffectiveSeverityLevel defines parameters for ListGroupIssues.
type ListGroupIssuesParamsEffectiveSeverityLevel string

// ListGroupIssuesParamsStatus defines parameters for ListGroupIssues.
type ListGroupIssuesParamsStatus string

// GetGroupIssueByIssueIDParams defines parameters for GetGroupIssueByIssueID.
type GetGroupIssueByIssueIDParams struct {
	// Version The requested version of the endpoint to process the request
	Version Version `form:"version" json:"version"`
}

// ListOrgIssuesParams defines parameters for ListOrgIssues.
type ListOrgIssuesParams struct {
	// Version The requested version of the endpoint to process the request
	Version Version `form:"version" json:"version"`

	// StartingAfter Return the page of results immediately after this cursor
	StartingAfter *StartingAfter `form:"starting_after,omitempty" json:"starting_after,omitempty"`

	// EndingBefore Return the page of results immediately before this cursor
	EndingBefore *EndingBefore `form:"ending_before,omitempty" json:"ending_before,omitempty"`

	// Limit Number of results to return per page
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// ScanItemId A scan item id to filter issues through their scan item relationship.
	ScanItemId *ScanItemId `form:"scan_item.id,omitempty" json:"scan_item.id,omitempty"`

	// ScanItemType A scan item types to filter issues through their scan item relationship.
	ScanItemType *ScanItemType `form:"scan_item.type,omitempty" json:"scan_item.type,omitempty"`

	// Type An issue type to filter issues.
	Type *Type `form:"type,omitempty" json:"type,omitempty"`

	// UpdatedBefore A filter to select issues updated before this date.
	UpdatedBefore *UpdatedBefore `form:"updated_before,omitempty" json:"updated_before,omitempty"`

	// UpdatedAfter A filter to select issues updated after this date.
	UpdatedAfter *UpdatedAfter `form:"updated_after,omitempty" json:"updated_after,omitempty"`

	// CreatedBefore A filter to select issues created before this date.
	CreatedBefore *CreatedBefore `form:"created_before,omitempty" json:"created_before,omitempty"`

	// CreatedAfter A filter to select issues created after this date.
	CreatedAfter *CreatedAfter `form:"created_after,omitempty" json:"created_after,omitempty"`

	// EffectiveSeverityLevel One or more effective severity levels to filter issues.
	EffectiveSeverityLevel *EffectiveSeverityLevel `form:"effective_severity_level,omitempty" json:"effective_severity_level,omitempty"`

	// Status An issue's status
	Status *Status `form:"status,omitempty" json:"status,omitempty"`

	// Ignored Whether an issue is ignored or not.
	Ignored *Ignored `form:"ignored,omitempty" json:"ignored,omitempty"`
}

// ListOrgIssuesParamsEffectiveSeverityLevel defines parameters for ListOrgIssues.
type ListOrgIssuesParamsEffectiveSeverityLevel string

// ListOrgIssuesParamsStatus defines parameters for ListOrgIssues.
type ListOrgIssuesParamsStatus string

// GetOrgIssueByIssueIDParams defines parameters for GetOrgIssueByIssueID.
type GetOrgIssueByIssueIDParams struct {
	// Version The requested version of the endpoint to process the request
	Version Version `form:"version" json:"version"`
}

// ListIssuesForManyPurlsParams defines parameters for ListIssuesForManyPurls.
type ListIssuesForManyPurlsParams struct {
	// Version The requested version of the endpoint to process the request
	Version Version `form:"version" json:"version"`
}

// FetchIssuesPerPurlParams defines parameters for FetchIssuesPerPurl.
type FetchIssuesPerPurlParams struct {
	// Version The requested version of the endpoint to process the request
	Version Version `form:"version" json:"version"`

	// Offset Specify the number of results to skip before returning results. Must be greater than or equal to 0. Default is 0.
	Offset *float32 `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit Specify the number of results to return. Must be greater than 0 and less than 1000. Default is 1000.
	Limit *float32 `form:"limit,omitempty" json:"limit,omitempty"`
}

// ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody defines body for ListIssuesForManyPurls for application/vnd.api+json ContentType.
type ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody = BulkPackageUrlsRequestBody

// AsResourcePathRepresentation returns the union data inside the Coordinate_Representations_Item as a ResourcePathRepresentation
func (t Coordinate_Representations_Item) AsResourcePathRepresentation() (ResourcePathRepresentation, error) {
	var body ResourcePathRepresentation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResourcePathRepresentation overwrites any union data inside the Coordinate_Representations_Item as the provided ResourcePathRepresentation
func (t *Coordinate_Representations_Item) FromResourcePathRepresentation(v ResourcePathRepresentation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResourcePathRepresentation performs a merge with any union data inside the Coordinate_Representations_Item, using the provided ResourcePathRepresentation
func (t *Coordinate_Representations_Item) MergeResourcePathRepresentation(v ResourcePathRepresentation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageRepresentation returns the union data inside the Coordinate_Representations_Item as a PackageRepresentation
func (t Coordinate_Representations_Item) AsPackageRepresentation() (PackageRepresentation, error) {
	var body PackageRepresentation
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageRepresentation overwrites any union data inside the Coordinate_Representations_Item as the provided PackageRepresentation
func (t *Coordinate_Representations_Item) FromPackageRepresentation(v PackageRepresentation) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageRepresentation performs a merge with any union data inside the Coordinate_Representations_Item, using the provided PackageRepresentation
func (t *Coordinate_Representations_Item) MergePackageRepresentation(v PackageRepresentation) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Coordinate_Representations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Coordinate_Representations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsIssueAttributesCoordinatesRepresentations0 returns the union data inside the IssueAttributes_Coordinates_Representations_Item as a IssueAttributesCoordinatesRepresentations0
func (t IssueAttributes_Coordinates_Representations_Item) AsIssueAttributesCoordinatesRepresentations0() (IssueAttributesCoordinatesRepresentations0, error) {
	var body IssueAttributesCoordinatesRepresentations0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueAttributesCoordinatesRepresentations0 overwrites any union data inside the IssueAttributes_Coordinates_Representations_Item as the provided IssueAttributesCoordinatesRepresentations0
func (t *IssueAttributes_Coordinates_Representations_Item) FromIssueAttributesCoordinatesRepresentations0(v IssueAttributesCoordinatesRepresentations0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueAttributesCoordinatesRepresentations0 performs a merge with any union data inside the IssueAttributes_Coordinates_Representations_Item, using the provided IssueAttributesCoordinatesRepresentations0
func (t *IssueAttributes_Coordinates_Representations_Item) MergeIssueAttributesCoordinatesRepresentations0(v IssueAttributesCoordinatesRepresentations0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueAttributesCoordinatesRepresentations1 returns the union data inside the IssueAttributes_Coordinates_Representations_Item as a IssueAttributesCoordinatesRepresentations1
func (t IssueAttributes_Coordinates_Representations_Item) AsIssueAttributesCoordinatesRepresentations1() (IssueAttributesCoordinatesRepresentations1, error) {
	var body IssueAttributesCoordinatesRepresentations1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueAttributesCoordinatesRepresentations1 overwrites any union data inside the IssueAttributes_Coordinates_Representations_Item as the provided IssueAttributesCoordinatesRepresentations1
func (t *IssueAttributes_Coordinates_Representations_Item) FromIssueAttributesCoordinatesRepresentations1(v IssueAttributesCoordinatesRepresentations1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueAttributesCoordinatesRepresentations1 performs a merge with any union data inside the IssueAttributes_Coordinates_Representations_Item, using the provided IssueAttributesCoordinatesRepresentations1
func (t *IssueAttributes_Coordinates_Representations_Item) MergeIssueAttributesCoordinatesRepresentations1(v IssueAttributesCoordinatesRepresentations1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueAttributesCoordinatesRepresentations2 returns the union data inside the IssueAttributes_Coordinates_Representations_Item as a IssueAttributesCoordinatesRepresentations2
func (t IssueAttributes_Coordinates_Representations_Item) AsIssueAttributesCoordinatesRepresentations2() (IssueAttributesCoordinatesRepresentations2, error) {
	var body IssueAttributesCoordinatesRepresentations2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueAttributesCoordinatesRepresentations2 overwrites any union data inside the IssueAttributes_Coordinates_Representations_Item as the provided IssueAttributesCoordinatesRepresentations2
func (t *IssueAttributes_Coordinates_Representations_Item) FromIssueAttributesCoordinatesRepresentations2(v IssueAttributesCoordinatesRepresentations2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueAttributesCoordinatesRepresentations2 performs a merge with any union data inside the IssueAttributes_Coordinates_Representations_Item, using the provided IssueAttributesCoordinatesRepresentations2
func (t *IssueAttributes_Coordinates_Representations_Item) MergeIssueAttributesCoordinatesRepresentations2(v IssueAttributesCoordinatesRepresentations2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIssueAttributesCoordinatesRepresentations3 returns the union data inside the IssueAttributes_Coordinates_Representations_Item as a IssueAttributesCoordinatesRepresentations3
func (t IssueAttributes_Coordinates_Representations_Item) AsIssueAttributesCoordinatesRepresentations3() (IssueAttributesCoordinatesRepresentations3, error) {
	var body IssueAttributesCoordinatesRepresentations3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIssueAttributesCoordinatesRepresentations3 overwrites any union data inside the IssueAttributes_Coordinates_Representations_Item as the provided IssueAttributesCoordinatesRepresentations3
func (t *IssueAttributes_Coordinates_Representations_Item) FromIssueAttributesCoordinatesRepresentations3(v IssueAttributesCoordinatesRepresentations3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIssueAttributesCoordinatesRepresentations3 performs a merge with any union data inside the IssueAttributes_Coordinates_Representations_Item, using the provided IssueAttributesCoordinatesRepresentations3
func (t *IssueAttributes_Coordinates_Representations_Item) MergeIssueAttributesCoordinatesRepresentations3(v IssueAttributesCoordinatesRepresentations3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueAttributes_Coordinates_Representations_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueAttributes_Coordinates_Representations_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLinkProperty0 returns the union data inside the LinkProperty as a LinkProperty0
func (t LinkProperty) AsLinkProperty0() (LinkProperty0, error) {
	var body LinkProperty0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty0 overwrites any union data inside the LinkProperty as the provided LinkProperty0
func (t *LinkProperty) FromLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty0 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty0
func (t *LinkProperty) MergeLinkProperty0(v LinkProperty0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLinkProperty1 returns the union data inside the LinkProperty as a LinkProperty1
func (t LinkProperty) AsLinkProperty1() (LinkProperty1, error) {
	var body LinkProperty1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLinkProperty1 overwrites any union data inside the LinkProperty as the provided LinkProperty1
func (t *LinkProperty) FromLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLinkProperty1 performs a merge with any union data inside the LinkProperty, using the provided LinkProperty1
func (t *LinkProperty) MergeLinkProperty1(v LinkProperty1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LinkProperty) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LinkProperty) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDeployedRiskFactor returns the union data inside the RiskFactor as a DeployedRiskFactor
func (t RiskFactor) AsDeployedRiskFactor() (DeployedRiskFactor, error) {
	var body DeployedRiskFactor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDeployedRiskFactor overwrites any union data inside the RiskFactor as the provided DeployedRiskFactor
func (t *RiskFactor) FromDeployedRiskFactor(v DeployedRiskFactor) error {
	v.Name = "deployed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDeployedRiskFactor performs a merge with any union data inside the RiskFactor, using the provided DeployedRiskFactor
func (t *RiskFactor) MergeDeployedRiskFactor(v DeployedRiskFactor) error {
	v.Name = "deployed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOSConditionRiskFactor returns the union data inside the RiskFactor as a OSConditionRiskFactor
func (t RiskFactor) AsOSConditionRiskFactor() (OSConditionRiskFactor, error) {
	var body OSConditionRiskFactor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOSConditionRiskFactor overwrites any union data inside the RiskFactor as the provided OSConditionRiskFactor
func (t *RiskFactor) FromOSConditionRiskFactor(v OSConditionRiskFactor) error {
	v.Name = "os_condition"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOSConditionRiskFactor performs a merge with any union data inside the RiskFactor, using the provided OSConditionRiskFactor
func (t *RiskFactor) MergeOSConditionRiskFactor(v OSConditionRiskFactor) error {
	v.Name = "os_condition"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPublicFacingRiskFactor returns the union data inside the RiskFactor as a PublicFacingRiskFactor
func (t RiskFactor) AsPublicFacingRiskFactor() (PublicFacingRiskFactor, error) {
	var body PublicFacingRiskFactor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPublicFacingRiskFactor overwrites any union data inside the RiskFactor as the provided PublicFacingRiskFactor
func (t *RiskFactor) FromPublicFacingRiskFactor(v PublicFacingRiskFactor) error {
	v.Name = "public_facing"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePublicFacingRiskFactor performs a merge with any union data inside the RiskFactor, using the provided PublicFacingRiskFactor
func (t *RiskFactor) MergePublicFacingRiskFactor(v PublicFacingRiskFactor) error {
	v.Name = "public_facing"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLoadedPackageRiskFactor returns the union data inside the RiskFactor as a LoadedPackageRiskFactor
func (t RiskFactor) AsLoadedPackageRiskFactor() (LoadedPackageRiskFactor, error) {
	var body LoadedPackageRiskFactor
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLoadedPackageRiskFactor overwrites any union data inside the RiskFactor as the provided LoadedPackageRiskFactor
func (t *RiskFactor) FromLoadedPackageRiskFactor(v LoadedPackageRiskFactor) error {
	v.Name = "loaded_package"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLoadedPackageRiskFactor performs a merge with any union data inside the RiskFactor, using the provided LoadedPackageRiskFactor
func (t *RiskFactor) MergeLoadedPackageRiskFactor(v LoadedPackageRiskFactor) error {
	v.Name = "loaded_package"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RiskFactor) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"name"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t RiskFactor) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "deployed":
		return t.AsDeployedRiskFactor()
	case "loaded_package":
		return t.AsLoadedPackageRiskFactor()
	case "os_condition":
		return t.AsOSConditionRiskFactor()
	case "public_facing":
		return t.AsPublicFacingRiskFactor()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t RiskFactor) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RiskFactor) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListGroupIssues request
	ListGroupIssues(ctx context.Context, groupId openapi_types.UUID, params *ListGroupIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupIssueByIssueID request
	GetGroupIssueByIssueID(ctx context.Context, groupId openapi_types.UUID, issueId PathIssueId20240123, params *GetGroupIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOrgIssues request
	ListOrgIssues(ctx context.Context, orgId openapi_types.UUID, params *ListOrgIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrgIssueByIssueID request
	GetOrgIssueByIssueID(ctx context.Context, orgId openapi_types.UUID, issueId PathIssueId20240123, params *GetOrgIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListIssuesForManyPurlsWithBody request with any body
	ListIssuesForManyPurlsWithBody(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListIssuesForManyPurlsWithApplicationVndAPIPlusJSONBody(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, body ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FetchIssuesPerPurl request
	FetchIssuesPerPurl(ctx context.Context, orgId OrgId, purl PackageUrl, params *FetchIssuesPerPurlParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListGroupIssues(ctx context.Context, groupId openapi_types.UUID, params *ListGroupIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGroupIssuesRequest(c.Server, groupId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupIssueByIssueID(ctx context.Context, groupId openapi_types.UUID, issueId PathIssueId20240123, params *GetGroupIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupIssueByIssueIDRequest(c.Server, groupId, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOrgIssues(ctx context.Context, orgId openapi_types.UUID, params *ListOrgIssuesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOrgIssuesRequest(c.Server, orgId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrgIssueByIssueID(ctx context.Context, orgId openapi_types.UUID, issueId PathIssueId20240123, params *GetOrgIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrgIssueByIssueIDRequest(c.Server, orgId, issueId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIssuesForManyPurlsWithBody(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIssuesForManyPurlsRequestWithBody(c.Server, orgId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListIssuesForManyPurlsWithApplicationVndAPIPlusJSONBody(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, body ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListIssuesForManyPurlsRequestWithApplicationVndAPIPlusJSONBody(c.Server, orgId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FetchIssuesPerPurl(ctx context.Context, orgId OrgId, purl PackageUrl, params *FetchIssuesPerPurlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFetchIssuesPerPurlRequest(c.Server, orgId, purl, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListGroupIssuesRequest generates requests for ListGroupIssues
func NewListGroupIssuesRequest(server string, groupId openapi_types.UUID, params *ListGroupIssuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScanItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scan_item.id", runtime.ParamLocationQuery, *params.ScanItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScanItemType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scan_item.type", runtime.ParamLocationQuery, *params.ScanItemType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_before", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveSeverityLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "effective_severity_level", runtime.ParamLocationQuery, *params.EffectiveSeverityLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ignored != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignored", runtime.ParamLocationQuery, *params.Ignored); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupIssueByIssueIDRequest generates requests for GetGroupIssueByIssueID
func NewGetGroupIssueByIssueIDRequest(server string, groupId openapi_types.UUID, issueId PathIssueId20240123, params *GetGroupIssueByIssueIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/issues/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOrgIssuesRequest generates requests for ListOrgIssues
func NewListOrgIssuesRequest(server string, orgId openapi_types.UUID, params *ListOrgIssuesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartingAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_after", runtime.ParamLocationQuery, *params.StartingAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndingBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScanItemId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scan_item.id", runtime.ParamLocationQuery, *params.ScanItemId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScanItemType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scan_item.type", runtime.ParamLocationQuery, *params.ScanItemType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_before", runtime.ParamLocationQuery, *params.UpdatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updated_after", runtime.ParamLocationQuery, *params.UpdatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedBefore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_before", runtime.ParamLocationQuery, *params.CreatedBefore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAfter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "created_after", runtime.ParamLocationQuery, *params.CreatedAfter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EffectiveSeverityLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "effective_severity_level", runtime.ParamLocationQuery, *params.EffectiveSeverityLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ignored != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignored", runtime.ParamLocationQuery, *params.Ignored); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrgIssueByIssueIDRequest generates requests for GetOrgIssueByIssueID
func NewGetOrgIssueByIssueIDRequest(server string, orgId openapi_types.UUID, issueId PathIssueId20240123, params *GetOrgIssueByIssueIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issue_id", runtime.ParamLocationPath, issueId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/issues/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListIssuesForManyPurlsRequestWithApplicationVndAPIPlusJSONBody calls the generic ListIssuesForManyPurls builder with application/vnd.api+json body
func NewListIssuesForManyPurlsRequestWithApplicationVndAPIPlusJSONBody(server string, orgId OrgId, params *ListIssuesForManyPurlsParams, body ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListIssuesForManyPurlsRequestWithBody(server, orgId, params, "application/vnd.api+json", bodyReader)
}

// NewListIssuesForManyPurlsRequestWithBody generates requests for ListIssuesForManyPurls with any type of body
func NewListIssuesForManyPurlsRequestWithBody(server string, orgId OrgId, params *ListIssuesForManyPurlsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/issues", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFetchIssuesPerPurlRequest generates requests for FetchIssuesPerPurl
func NewFetchIssuesPerPurlRequest(server string, orgId OrgId, purl PackageUrl, params *FetchIssuesPerPurlParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "org_id", runtime.ParamLocationPath, orgId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "purl", runtime.ParamLocationQuery, purl)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/packages/%s/issues", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, params.Version); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListGroupIssuesWithResponse request
	ListGroupIssuesWithResponse(ctx context.Context, groupId openapi_types.UUID, params *ListGroupIssuesParams, reqEditors ...RequestEditorFn) (*ListGroupIssuesResponse, error)

	// GetGroupIssueByIssueIDWithResponse request
	GetGroupIssueByIssueIDWithResponse(ctx context.Context, groupId openapi_types.UUID, issueId PathIssueId20240123, params *GetGroupIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*GetGroupIssueByIssueIDResponse, error)

	// ListOrgIssuesWithResponse request
	ListOrgIssuesWithResponse(ctx context.Context, orgId openapi_types.UUID, params *ListOrgIssuesParams, reqEditors ...RequestEditorFn) (*ListOrgIssuesResponse, error)

	// GetOrgIssueByIssueIDWithResponse request
	GetOrgIssueByIssueIDWithResponse(ctx context.Context, orgId openapi_types.UUID, issueId PathIssueId20240123, params *GetOrgIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*GetOrgIssueByIssueIDResponse, error)

	// ListIssuesForManyPurlsWithBodyWithResponse request with any body
	ListIssuesForManyPurlsWithBodyWithResponse(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListIssuesForManyPurlsResponse, error)

	ListIssuesForManyPurlsWithApplicationVndAPIPlusJSONBodyWithResponse(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, body ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ListIssuesForManyPurlsResponse, error)

	// FetchIssuesPerPurlWithResponse request
	FetchIssuesPerPurlWithResponse(ctx context.Context, orgId OrgId, purl PackageUrl, params *FetchIssuesPerPurlParams, reqEditors ...RequestEditorFn) (*FetchIssuesPerPurlResponse, error)
}

type ListGroupIssuesResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *ListIssues200
	ApplicationvndApiJSON401 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON403 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON404 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON500 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGroupIssuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGroupIssuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupIssueByIssueIDResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *GetIssue20020240123
	ApplicationvndApiJSON400 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON401 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON403 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON404 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON409 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON500 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGroupIssueByIssueIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupIssueByIssueIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOrgIssuesResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *ListIssues200
	ApplicationvndApiJSON401 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON403 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON404 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON500 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
}

// Status returns HTTPResponse.Status
func (r ListOrgIssuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOrgIssuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrgIssueByIssueIDResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *GetIssue20020240123
	ApplicationvndApiJSON400 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON401 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON403 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON404 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON409 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
	ApplicationvndApiJSON500 *struct {
		Errors []struct {
			// Code An application-specific error code, expressed as a string value.
			Code *string `json:"code,omitempty"`

			// Detail A human-readable explanation specific to this occurrence of the problem.
			Detail string `json:"detail"`

			// Id A unique identifier for this particular occurrence of the problem.
			Id     *openapi_types.UUID     `json:"id,omitempty"`
			Meta   *map[string]interface{} `json:"meta,omitempty"`
			Source *struct {
				// Parameter A string indicating which URI query parameter caused the error.
				Parameter *string `json:"parameter,omitempty"`

				// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
				Pointer *string `json:"pointer,omitempty"`
			} `json:"source,omitempty"`

			// Status The HTTP status code applicable to this problem, expressed as a string value.
			Status string `json:"status"`

			// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
			Title *string `json:"title,omitempty"`
		} `json:"errors"`
		Jsonapi struct {
			// Version Version of the JSON API specification this server supports.
			Version string `json:"version"`
		} `json:"jsonapi"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOrgIssueByIssueIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrgIssueByIssueIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListIssuesForManyPurlsResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *IssuesWithPurlsResponse
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON403 *N403
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON409 *N409
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r ListIssuesForManyPurlsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListIssuesForManyPurlsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FetchIssuesPerPurlResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *IssuesResponse
	ApplicationvndApiJSON400 *N400
	ApplicationvndApiJSON401 *N401
	ApplicationvndApiJSON403 *N403
	ApplicationvndApiJSON404 *N404
	ApplicationvndApiJSON409 *N409
	ApplicationvndApiJSON500 *N500
}

// Status returns HTTPResponse.Status
func (r FetchIssuesPerPurlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FetchIssuesPerPurlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListGroupIssuesWithResponse request returning *ListGroupIssuesResponse
func (c *ClientWithResponses) ListGroupIssuesWithResponse(ctx context.Context, groupId openapi_types.UUID, params *ListGroupIssuesParams, reqEditors ...RequestEditorFn) (*ListGroupIssuesResponse, error) {
	rsp, err := c.ListGroupIssues(ctx, groupId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGroupIssuesResponse(rsp)
}

// GetGroupIssueByIssueIDWithResponse request returning *GetGroupIssueByIssueIDResponse
func (c *ClientWithResponses) GetGroupIssueByIssueIDWithResponse(ctx context.Context, groupId openapi_types.UUID, issueId PathIssueId20240123, params *GetGroupIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*GetGroupIssueByIssueIDResponse, error) {
	rsp, err := c.GetGroupIssueByIssueID(ctx, groupId, issueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupIssueByIssueIDResponse(rsp)
}

// ListOrgIssuesWithResponse request returning *ListOrgIssuesResponse
func (c *ClientWithResponses) ListOrgIssuesWithResponse(ctx context.Context, orgId openapi_types.UUID, params *ListOrgIssuesParams, reqEditors ...RequestEditorFn) (*ListOrgIssuesResponse, error) {
	rsp, err := c.ListOrgIssues(ctx, orgId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOrgIssuesResponse(rsp)
}

// GetOrgIssueByIssueIDWithResponse request returning *GetOrgIssueByIssueIDResponse
func (c *ClientWithResponses) GetOrgIssueByIssueIDWithResponse(ctx context.Context, orgId openapi_types.UUID, issueId PathIssueId20240123, params *GetOrgIssueByIssueIDParams, reqEditors ...RequestEditorFn) (*GetOrgIssueByIssueIDResponse, error) {
	rsp, err := c.GetOrgIssueByIssueID(ctx, orgId, issueId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrgIssueByIssueIDResponse(rsp)
}

// ListIssuesForManyPurlsWithBodyWithResponse request with arbitrary body returning *ListIssuesForManyPurlsResponse
func (c *ClientWithResponses) ListIssuesForManyPurlsWithBodyWithResponse(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListIssuesForManyPurlsResponse, error) {
	rsp, err := c.ListIssuesForManyPurlsWithBody(ctx, orgId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIssuesForManyPurlsResponse(rsp)
}

func (c *ClientWithResponses) ListIssuesForManyPurlsWithApplicationVndAPIPlusJSONBodyWithResponse(ctx context.Context, orgId OrgId, params *ListIssuesForManyPurlsParams, body ListIssuesForManyPurlsApplicationVndAPIPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*ListIssuesForManyPurlsResponse, error) {
	rsp, err := c.ListIssuesForManyPurlsWithApplicationVndAPIPlusJSONBody(ctx, orgId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListIssuesForManyPurlsResponse(rsp)
}

// FetchIssuesPerPurlWithResponse request returning *FetchIssuesPerPurlResponse
func (c *ClientWithResponses) FetchIssuesPerPurlWithResponse(ctx context.Context, orgId OrgId, purl PackageUrl, params *FetchIssuesPerPurlParams, reqEditors ...RequestEditorFn) (*FetchIssuesPerPurlResponse, error) {
	rsp, err := c.FetchIssuesPerPurl(ctx, orgId, purl, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFetchIssuesPerPurlResponse(rsp)
}

// ParseListGroupIssuesResponse parses an HTTP response from a ListGroupIssuesWithResponse call
func ParseListGroupIssuesResponse(rsp *http.Response) (*ListGroupIssuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGroupIssuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIssues200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupIssueByIssueIDResponse parses an HTTP response from a GetGroupIssueByIssueIDWithResponse call
func ParseGetGroupIssueByIssueIDResponse(rsp *http.Response) (*GetGroupIssueByIssueIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupIssueByIssueIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIssue20020240123
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseListOrgIssuesResponse parses an HTTP response from a ListOrgIssuesWithResponse call
func ParseListOrgIssuesResponse(rsp *http.Response) (*ListOrgIssuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOrgIssuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIssues200
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetOrgIssueByIssueIDResponse parses an HTTP response from a GetOrgIssueByIssueIDWithResponse call
func ParseGetOrgIssueByIssueIDResponse(rsp *http.Response) (*GetOrgIssueByIssueIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrgIssueByIssueIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetIssue20020240123
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest struct {
			Errors []struct {
				// Code An application-specific error code, expressed as a string value.
				Code *string `json:"code,omitempty"`

				// Detail A human-readable explanation specific to this occurrence of the problem.
				Detail string `json:"detail"`

				// Id A unique identifier for this particular occurrence of the problem.
				Id     *openapi_types.UUID     `json:"id,omitempty"`
				Meta   *map[string]interface{} `json:"meta,omitempty"`
				Source *struct {
					// Parameter A string indicating which URI query parameter caused the error.
					Parameter *string `json:"parameter,omitempty"`

					// Pointer A JSON Pointer [RFC6901] to the associated entity in the request document.
					Pointer *string `json:"pointer,omitempty"`
				} `json:"source,omitempty"`

				// Status The HTTP status code applicable to this problem, expressed as a string value.
				Status string `json:"status"`

				// Title A short, human-readable summary of the problem that SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
				Title *string `json:"title,omitempty"`
			} `json:"errors"`
			Jsonapi struct {
				// Version Version of the JSON API specification this server supports.
				Version string `json:"version"`
			} `json:"jsonapi"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseListIssuesForManyPurlsResponse parses an HTTP response from a ListIssuesForManyPurlsWithResponse call
func ParseListIssuesForManyPurlsResponse(rsp *http.Response) (*ListIssuesForManyPurlsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListIssuesForManyPurlsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssuesWithPurlsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseFetchIssuesPerPurlResponse parses an HTTP response from a FetchIssuesPerPurlWithResponse call
func ParseFetchIssuesPerPurlResponse(rsp *http.Response) (*FetchIssuesPerPurlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FetchIssuesPerPurlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssuesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest N401
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest N403
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest N404
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest N409
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest N500
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}
